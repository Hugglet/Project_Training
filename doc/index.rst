"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Разработка и развертывание веб-приложения на языке Python
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

:Автор: Аксенов А.В.

.. role:: sql(code)
   :language: sql

.. role:: bat(code)
   :language: bat

.. contents:: Содержание
   :depth: 3

===========
Предисловие
===========

Данное пособие в силу ограниченности объема не нацелено на полноту описания всех тонкостей создания веб-приложений, а также всех возможных вариантов архитектур, использующихся в современной веб-разработке. В угоду законченности описания были опущены следующие темы:

* рассмотрение и сопоставление различных стеков для разработки (таких как NodeJS + Express, PHP + Laravel, C# + ASP.NET, Java + Spring и других)
* сравнение альтернативных веб-фреймворков для Python (Django, FastAPI, AIOHTTP и других)
* использование ORM-библиотек для доступа к данным из кода Python (SQLAlchemy, Pony, Peewee и других)
* описание значительного количества повсеместно используемых в современной разработке концепций и технологий создания API, таких как REST, GraphQL
* обзор приемов архитектурных шаблонов программных систем (монолитная архитектура, микросервисная архитектура, бессерверная архитектура и других)
* обзор повсеместно применяющиеся в промышленной разработке технологии контейнеризации и виртуализации
* описание техник и приемов тестирования, а также непрерывной интеграции и непрерывного развертывания
* описание технологий и приемов создания фронтенда, в том числе SPA-приложений
* обзор, сравнение и описание принципов настройки высокопроизводительных веб-серверов (Nginx, Apache и других)

Тем не менее, освоение материала данного пособия не только не противоречит, но служит хорошим фундаментом для дальнейшего погружения в область разработки веб-приложений с изучением названных и прочих сопутствующих тем.

С другой стороны, настоящее пособие также не является учебником, позволяющим овладеть веб-разработкой на Python с нуля. Программирование как таковое, как и различные разделы веб-технологий, уже представляет собой довольно объемную дисциплину, поэтому предполагается, что изучающий тему веб-разработки на Python человек уже знаком с этим материалом.

Систематизируя вышесказанное, можно сказать, что базовыми требованиями для использующих данное пособие студентов являются владение следующими темами:

* Основы языка Python
* Приемы работы с интерфейсом командной строки
* Системы контроля версий, в частности git
* Принципы работы реляционных баз данных, проектирование схемы данных, а также основы стандартного SQL и управление транзакциями
* Основы HTML и CSS
* Принципы работы протокола HTTP

Вышеперечисленные темы не будут затронуты в настоящем пособии, но являются необходимыми для успешного освоения его материала.

=================
Структура пособия
=================

Данное пособие структурировано в соответствии с этапами индивидуальной работы над проектом, представляющим собой веб-приложение на языке Python. Отдельные разделы посвящены работе с требованиями, реализации подсистемы хранения данных, реализации логики, интерфейса, развертыванию и ряду других тем. Основной упор сделан на описание технологий и их взаимодействия, при этом теории отводится вспомогательная роль. Сознательно опущены этапы выбора платформы, стека технологий и принятия некоторых архитектурных решений. Согласно названию пособия, целью работы будет создание веб-приложения, а средством реализации -- стек Python.

В целом, в рамках учебного процесса разработка программного обеспечения не предполагает жесткого деления на фазы с фиксированной продолжительностью и со строгой отчетностью. По этой причине разделы пособия могут быть освоены в произвольном порядке, а сама работа над проектом может вестись с отступлением от итеративных методологий, описанных в специализированной литературе [#uml]_. Более того, в реальных проектах чаще всего задействованы команды разработчиков и других специалистов (руководителей, системных аналитиков, тестировщиков и т.д.), и необходимость координировать их взаимодействие играет значительную роль в организации процесса разработки. Перечисленные факторы делают настоящее пособие и осваиваемую методологию выполнения индивидуальных учебных проектов ограниченно пригодными для использования в промышленных условиях.

В дальнейшем будем предполагать, что под терминами "фаза", "этап" и прочими, относящими к описанию процесса реализации системы будут пониматься соответствующие термины учебного процесса, а не промышленного.

=========================
Формулирование требований
=========================

Одна из первых фаз работы над программным проектом -- фаза формализации и анализа требований. Важно уделить данному этапу особое внимание, поскольку в процессе этой работы появляется представление о результате, который должен быть получен, и целях, которые должны быть достигнуты по итогу создания проекта.

Требования классически разделяются на функциональные и нефункциональные.

Функциональные требования -- те, которые относятся к поведению проектируемой системы. Отвечают на вопросы: 

* какими свойствами обладает система?
* какие возможности она предоставляет?
  
Функциональные требования формулируются на естественном языке (как правило, при общении с заказчиком) и могут быть формализованы при помощи модели прецедентов. Далее приводится очень краткое описание этой модели, за более детальным описанием следует обратиться к специализированной литературе [#uml]_.

Каждому требованию ставится в соответствие прецедент, который не имеет внутренней структуры (может быть представлен в виде "черного ящика"), описывается в терминах предметной области и моделирует некоторую возможность системы.

Например, прецедентом может быть "Система записывает слушателя на курс".

Такой подход, когда детали реализации не уточняются на этапе моделирования, позволяет получить наглядную и внятную модель требований к системе, которая может быть уточнена уже в процессе реализации посредством развернутого описания каждого прецедента.

Второй компонент модели прецедентов -- акторы (исполнители). Чаще всего акторами являются пользователи системы (например, слушатель курса), но также ими могут быть и другие системы, внешние по отношению к данной. Актор обладает поведением, которое заключается в использовании прецедентов для достижения его целей.

Часто модели прецедентов графически изображаются в виде диаграммы прецедентов (также называемой диаграммой вариантов использования, use case diagram).

Нефункциональные требования -- те требования, которые не описывают возможности системы. К таковым относятся, помимо прочих, требования к интерфейсу, эффективности работы, надежности и прочие.

Этап формулирования требований к системе завершается составлением и согласованием технического задания, документа, в достаточной степени детально перечисляющего функциональные и нефункциональные требования, а также какие-то дополнительные ограничения и условия (цели, сроки, стоимость и прочее).

.. [#uml] Ларман. Применение UML 2.0 и шаблонов проектирования

=====================================
Реализация подсистемы хранения данных
=====================================

Обзор и установка СУБД PostgreSQL
=================================

Хранилище данных -- важная часть любой информационной системы, и выбор технологии для ее реализации зачастую во многом оказывает влияние на архитектуру системы в целом.

В современной разработке принято делать радикальный выбор и противопоставлять друг другу подходы, использующие реляционные базы данных (такие как Oracle, Microsoft SQL Server, PostgreSQL, MySQL и другие) и NoSQL-системы. Следует отметить, что это не вполне корректная постановка вопроса, ввиду того, что под термином NoSQL скрывается множество различных технологий хранения данных, каждая из которых представлена рядом продуктов, которые его реализуют. В свете этого уместно говорить о выборе модели данных для хранилища данных конкретной системы, а вариантами этого выбора могут быть либо реляционная модель данных, либо какая-то из NoSQL моделей (документоориентированная, "ключ-значение", графовая, колоночная и другие). Более того, с развитием облачных технологий получил популярность отход от концепции единой модели данных для приложения, и часто различные компоненты системы используют в качестве хранилищ базы данных тех моделей, которые наиболее подходят под требования по функциональности и производительности.

В данном пособии была выбрана реляционная модель данных как наиболее распространенная в академической сфере и достаточно подходящая для веб-разработки, в качестве системы управления базами данных используется PostgreSQL. Данная СУБД занимает довольно прочные позиции в рейтингах популярности благодаря открытости и богатым функциональным возможностям. Помимо этого, в рамках учебного проекта эта система предоставляет дополнительные удобства при облачном развертывании, описанном в соответствующем разделе данного пособия.

PostgreSQL -- реляционная система управления базами данных, функционирующая в архитектуре "клиент-сервер". Это означает, что, в отличие, к примеру от Microsoft Access и SQLite, СУБД PostgreSQL представляет собой отдельный процесс ("сервер"), запущенный постоянно и обслуживающий запросы от приложений ("клиентов"). Данные хранятся в базах данных под управлением сервера (причем на одном сервере может быть несколько баз данных) и доступны клиенту только посредством обращения к последнему. Клиент и сервер могут быть запущены как на одном компьютере, так и на различных, во втором случае взаимодействие осуществляется по сети. 

В качестве клиента может выступать специализированное приложение (примеры будут рассмотрены далее), позволяющее подключаться к серверу, выполнять запросы, управлять схемой базы данных и просматривать данные. На этапе разработки и первоначальной настройки системы хранения данных необходимо использовать приложение-клиент, после чего при разработке веб-приложения и в дальнейшем при его эксплуатации клиентом для PostgreSQL будет уже сервер приложения.

Забегая вперед, необходимо отметить, что работа с сервером PostgreSQL может проходить двумя способами: с помощью установки на локальный компьютер, на котором ведется разработка, либо с помощью облачного развертывания. Второй способ описан в соответствующем разделе пособия и обладает преимуществом отсутствия необходимости установки какого-либо программного обеспечения на локальный компьютер (что может быть критично при отсутствии у разработчика прав на установку ПО) и какого-либо конфигурирования установленного сервера.

Тем не менее, в данном пособии будет рассмотрена разработка и отладка с использование локальной установки PostgreSQL. Преимуществом данного подхода являются:

* получение опыта работы с локальным экземпляром СУБД
* более высокая производительность запросов, что важно для ускорения циклов разработки и отладки
* отсутствие необходимости доступа к сети интернет для доступа к данным.

В случае если читатель предпочитает работу с облачным экземпляром СУБД, он волен пропустить инструкции по установке локального экземпляра и воспользоваться соответствующим разделом пособия. 

Установка сервера PostgreSQL производится по-разному в зависимости от операционной системы:

* Для дистрибутивов Linux -- из репозиториев программного обеспечения
* Для MacOS -- также из репозиториев или с помощью дистрибутива Postgres.app [#postgresapp]_ или дистрибутива EnterpriseDB [#edb]_
* Для Windows -- с помощью дистрибутива Постгрес Профессиональный [#postgrespro]_ или дистрибутива EnterpriseDB [#edb]_

.. [#postgresapp] https://postgresapp.com/
.. [#edb] https://www.enterprisedb.com/downloads/postgres-postgresql-downloads
.. [#postgrespro] https://postgrespro.ru/windows

При установке следует обратить внимание на следующее:

* Установлены должны быть и серверные, и клиентские компоненты
* Для сервера необходимо задать и запомнить пароль суперпользователя postgres (в некоторых дистрибутивах можно поменять его имя, делать это необязательно), при этом по умолчанию создается пустая база данных с тем же именем

Остальные настройки можно оставить по умолчанию. Конфигурирование локального сервера с точки зрения настройки сетевого доступа и безопасности выходит за рамки вопросов, рассматриваемых в данном пособии. Желающие могут обратиться к русскому переводу официальной документации, выполненному компанией Постгрес Профессиональный [#postgresdocs]_.

.. [#postgresdocs] https://postgrespro.ru/docs/postgresql/17/

В качестве клиента PostgreSQL может использоваться множество вариантов приложений. Рассмотрим бесплатные открытые кроссплатформенные и активно развиваемые клиенты:

* psql -- официальный клиент командной строки, поставляемый вместе с сервером PostgreSQL во всех дистрибутивах и доступный в репозиториях программного обеспечения
* DBeaver [#dbeaver]_ -- универсальное приложение с графическим интерфейсом, представляющее возможность разработки и администрирования, помимо PostgreSQL, большого количества вариантов СУБД. Реализовано на базе платформы Eclipse на языке Java.
* pgAdmin 4 [#pgadmin]_ -- веб-приложение для разработки и администрирования PostgreSQL, входящее в состав дистрибутивов EnterpriseDB для Windows и MacOS. Релизовано на Python и React.

.. [#dbeaver] https://dbeaver.io/download/
.. [#pgadmin] https://www.pgadmin.org/download/

В рамках данного пособия будет рассмотрена работа с приложением psql в качестве клиента.

Основные приемы работы с программой psql
========================================

psql -- приложение командной строки, это означает, что у него отсутствует графический интерфейс, и для работы с ним необходимо предварительно запустить командный интерпретатор операционной системы, на которой происходит разработка.

В случае работы из командной строки Windows перед запуском psql имеет смысл сменить кодировку консоли (это позволит корректно отображать кириллические символы), а также добавить путь к исполняемому файлу psql в переменную окружения PATH:

.. code-block:: bat
    
    chcp 1251
    PATH C:\Program Files\PostgreSQL\17\bin;%PATH%

Следует отметить, что путь установки в конкретной системе может быть отличен.

Запуск psql осуществляется следующей командой:

.. code-block:: bat

    psql -h host -p port -d db_name -U user_name

Рассмотрим параметры командной строки приложения psql.

-h  имя или адрес хоста, на котором запущен сервер (по умолчанию будет произведена попытка подключения к локально установленному серверу, поэтому значением имени хоста по умолчанию является localhost)
-p  порт, на котором запущен сервер PostgreSQL (по умолчанию 5432)
-d  имя базы данных, к которой происходит подключение (как уже упоминалось, на одном сервере может быть несколько баз данных)
-U  имя пользователя (по умолчанию используется имя пользователя операционной системы, от имени которого выполняет запуск клиента)

Если опустить имя базы данных, то произойдет попытка подключения к базе данных, имеющей то же имя, что и пользователь, с помощью которого происходит подключение. Если ее не существует, в соединении будет отказано.

По умолчанию, как уже было упомянуто, создается пользователь postgres, обладающий привилегиями администратора, используя которые можно произвести подготовку экземпляра СУБД к работе, а также база данных postgres. Подключение к локальному экземпляру СУБД с помощью имени пользователя postgres к одноименной базе данных выполняется командой:

.. code-block:: bat
    
    psql -U postgres

После этого потребуется ввести пароль. 

На Unix-подобных операционных системах (Linux, MacOS) для определенных конфигураций PostgreSQL, по умолчанию может использоваться тип аутентификации при помощи Unix-сокетов методом peer, который идентифицирует пользователя на основании имени пользователя операционной системы, от которого исполняется процесс клиента, при это не требуя пароля. Если имя пользователя операционной системы отличается от имени пользователя базы данных (в данном случае -- postgres), предыдущая команда может завершиться ошибкой аутентификации. В таких случаях рекомендуется использовать следующую команду, чтобы явно использовать TCP/IP и тип аутентификации host:

.. code-block:: bat
    
    psql -h localhost -U postgres

Если подключение было успешно, появляется приглашение командной строки в виде имени текущей базы данных и символов ``=#``, и становится доступно выполнение запросов на SQL, а также ряда команд интерактивного режима. 

.. image:: ./img/connection.png

База данных в PostgreSQL может содержать несколько схем (schema), которые являются логическими структурами, группирующими объекты базы данных, такие как таблицы, представления, индексы, триггеры и т.д. На работу базы данных схемы не влияют, но позволяют изолировать объекты внутри базы данных, используя пространства имен (например, две таблицы в одной базе данных могут иметь одинаковые имена, будучи расположенными в разных схемах), а также управлять доступом к объектам (например, пользователь может иметь доступ к одной схеме и не иметь доступа к другой). По умолчанию в каждой базе данных создается одиночная схема ``public``, куда помещаются все создаваемые таблицы. Таким образом, при создании таблицы ``my_table`` ее полным именем будет ``public.my_table``.

Запросы на SQL вводятся непосредственно после приглашения командной строки и заканчиваются точкой с запятой. Если запрос имеет большой размер, его можно разбить на несколько строк переносами прямо в командной строке. После последней строки необходимо поставить точку с запятой, в этом случае psql распознает ее как окончание команды и попытается выполнить этот запрос.

.. image:: ./img/query.png

Команды оболочки psql начинаются с символа обратной косой черты ``\``. Рассмотрим некоторые из команд.

Вывести список пользователей:

.. code-block:: psql

    \du

Вывести список баз данных:

.. code-block:: psql

    \l

Сменить текущую базу данных:

.. code-block:: psql

    \c db_name

Вывести список схем в текущей базе данных:

.. code-block:: psql

    \dn

Вывести список таблиц в текущей базе данных:

.. code-block:: psql

    \dt

Вывести информацию о таблице:

.. code-block:: psql

    \d table_name

Открыть системный текстовый редактор по умолчанию для ввода команды (полезно для создания длинных команд):

.. code-block:: psql

    \e

Выполнить команды из внешнего файла:

.. code-block:: psql

    \i file_name

Выйти из интерактивного сеанса psql:

.. code-block:: psql

    \q

.. image:: ./img/commands.png

В случае смены базы данных будет изменено и приглашение командной строки, при этом последующие команды и запросы будут выполняться уже к новой базе данных.

.. image:: ./img/changedb.png

Создание пользователя и базы данных в psql
==========================================

Плохой практикой считается использование для работы с данными полномочий суперпользователя. На этапе разработки это чревато тяжелыми последствиями ошибок, а на этапе эксплуатации это открывает злоумышленникам широкие возможности по дестабилизации работы системы, порче и компрометации данных. С другой стороны подход, при котором каждый пользователь приложения имеет свою собственную учетную запись в системе управления базами данных, также не является распространенным. Стандартом считается схема, при которой для приложения создается одиночный пользователь с ограниченными правами, и доступ приложения к серверу базы данных осуществляется от имени этого пользователя, в том время как управление учетными записями пользователей приложения и разграничение их доступа к функциям системы и к данным возлагается на само приложение.

Для того, чтобы создать базу данных для приложения и пользователя, который будет с ней работать, отличного от суперпользователя (postgres), необходимо выполнить следующие шаги:

#. Подключиться к серверу пользователем postgres

    .. code-block:: bat
        
        psql -U postgres

#. Выполнить команду создания нового пользователя, указав его пароль (рекомендуется воздержаться от использования кириллицы при задании имени пользователя и пароля)

    .. code-block:: sql

        CREATE USER your_user_name WITH PASSWORD 'your_user_password';

#. Выполнить команду создания базы данных (также рекомендуется избегать кириллицы в названии базы данных; если база данных уже создана, выполнять эту команду нет необходимости)

    .. code-block:: sql
        
        CREATE DATABASE your_db_name; 

#. Сменить текущую базу данных: 

    .. code-block:: psql

        \с your_db_name

#. Выполнить команды предоставления разрешений на созданную базу данных, ее схему public и все таблицы в ней только что созданному пользователю:

    .. code-block:: sql

        GRANT ALL ON DATABASE your_db_name TO your_user_name;
        GRANT ALL ON SCHEMA public TO your_user_name;
        GRANT ALL ON ALL TABLES IN SCHEMA public TO your_user_name;
    
#. Выйти из psql

    .. code-block:: psql

        \q

После этого можно проверить внесенные изменения, подключившись новым пользователем к созданной базе данных и создав в ней таблицу:

.. code-block:: bat
    
    psql -U your_user_name -d your_db_name

На Unix-системах (Linux, MacOS) при возникновании ошибок аутентификации рекомендуется использовать следующую команду, чтобы принудительно использовать тип аутентификации host:

.. code-block:: bash
    
    psql -h localhost -U your_user_name -d your_db_name

Особенности языка SQL в СУБД PostgreSQL
=======================================

В целом PostgreSQL во многом придерживается стандарта SQL в конструкциях используемого в этой СУБД диалекта SQL [#sql]_ (за исключением случаев, когда речь идет о процедурном расширении PL/pgSQL [#plpgsql]_). В этом подразделе уместно остановиться на существующих различиях, которые могут встретиться в части создания базы данных и работы с данными.


.. [#sql] https://postgrespro.ru/docs/postgresql/17/sql
.. [#plpgsql] https://postgrespro.ru/docs/postgresql/17/plpgsql

В PostgreSQL используются следующие типы данных (через косую черту перечислены несколько возможных вариантов):

+----------------------------------------+-----------------------------------------------------------------------+
| Тип данных                             | Комментарий                                                           |
+========================================+=======================================================================+
| SMALLINT / INT2                        | Целое число (2 байта)                                                 |
+----------------------------------------+-----------------------------------------------------------------------+
| INT / INTEGER / INT4                   | Целое число (4 байта)                                                 |
+----------------------------------------+-----------------------------------------------------------------------+
| BIGINT / INT8                          | Целое число (8 байт)                                                  |
+----------------------------------------+-----------------------------------------------------------------------+
| REAL / FLOAT(24) / FLOAT4              | Вещественное число с плавающей точкой одинарной точности              |
+----------------------------------------+-----------------------------------------------------------------------+
| DOUBLE PRECISION / FLOAT(53) / FLOAT8  | Вещественное число с плавающей точкой двойной точности                |
+----------------------------------------+-----------------------------------------------------------------------+
| NUMERIC(m, n) / DECIMAL(m, n)          | Вещественное число с фиксированной точкой                             |
+----------------------------------------+-----------------------------------------------------------------------+
| CHAR(n) / CHARACTER(n)                 | Текстовая строка фиксированной длины (не рекомендуется использовать)  |
+----------------------------------------+-----------------------------------------------------------------------+
| VARCHAR(n) / CHARACTER VARYING(n)      | Текстовая строка переменной длины (не рекомендуется использовать)     |
+----------------------------------------+-----------------------------------------------------------------------+
| VARCHAR / CHARACTER VARYING / TEXT     | Текстовая строка неограниченной длины                                 |
+----------------------------------------+-----------------------------------------------------------------------+
| DATE                                   | Дата                                                                  |
+----------------------------------------+-----------------------------------------------------------------------+
| TIME                                   | Время                                                                 |
+----------------------------------------+-----------------------------------------------------------------------+
| TIMESTAMPTZ / TIMESTAMP WITH TIME ZONE | Дата и время с часовым поясом                                         |
+----------------------------------------+-----------------------------------------------------------------------+
| BYTEA                                  | Двоичные данные                                                       |
+----------------------------------------+-----------------------------------------------------------------------+
| BOOLEAN                                | Логическое значение                                                   |
+----------------------------------------+-----------------------------------------------------------------------+

Идентификаторы (к примеру, названия таблиц или колонок) в тексте скрипта SQL могут браться или не браться в двойные кавычки. В случае использования кавычек идентификаторы становятся чувствительными к регистру, при этом в качестве идентификаторов можно применять ключевые слова SQL, например, ``"group"``.

Колонка с автоинкрементом ("колонка идентификации") задается с помощью предложения :sql:`GENERATED BY DEFAULT AS IDENTITY` или :sql:`GENERATED ALWAYS AS IDENTITY`.

.. code-block:: sql

    CREATE TABLE "t1" (
        "A" INTEGER GENERATED BY DEFAULT AS IDENTITY,
        "B" INTEGER
    );

    CREATE TABLE "t2" (
        "A" INTEGER GENERATED ALWAYS AS IDENTITY,
        "B" INTEGER
    );

И в таблице ``t1``, и в таблице ``t2`` колонка A будет в каждой новой строке принимать новое значение, равное увеличенному на 1 предыдущему сгенерированному для этой таблицы значению (первое сгенерированное значение будет равно 1). Разница между двумя вариантами заключается в том, что предложение ``BY DEFAULT`` позволяет вручную задавать значение для колонки ``A``, а также изменять значения в этой колонке, а выражение ``ALWAYS`` будет вызывать ошибку при попытке выполнить эти действия.

Для работы с датой и временем в PostgreSQL используются следующие функции:

+-----------------------+---------------------------------------+
| Функция               | Комментарий                           |
+=======================+=======================================+
| CURRENT_DATE          | Текущая дата                          |
+-----------------------+---------------------------------------+
| LOCALTIME             | Текущее время                         |
+-----------------------+---------------------------------------+
| CURRENT_TIMESTAMP     | Текущие дата и время с часовым поясом |
+-----------------------+---------------------------------------+
| AGE                   | Разница между датами                  |
+-----------------------+---------------------------------------+
| EXTRACT(YEAR FROM d)  | Извлечение года из даты               |
+-----------------------+---------------------------------------+
| EXTRACT(MONTH FROM d) | Извлечение месяца из даты             |
+-----------------------+---------------------------------------+
| EXTRACT(DAY FROM d)   | Извлечение дня из даты                |
+-----------------------+---------------------------------------+
| EXTRACT(HOUR FROM d)  | Извлечение часа из даты               |
+-----------------------+---------------------------------------+
| EXTRACT(DOW FROM d)   | Извлечение дня недели из даты         |
+-----------------------+---------------------------------------+

Примеры:

.. code-block:: sql
    
    SELECT CURRENT_DATE;                         -- текущая дата
    SELECT AGE(CURRENT_DATE, '2020-01-01');      -- количество времени, прошедшее с 01.01.2020
    SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP); -- текущий год

Преобразование выражения к другому типу данных производится следующим образом:

.. code-block:: sql

    CAST(expression AS type)

Примеры:

.. code-block:: sql
    
    SELECT CAST('2' AS INTEGER) + 2 AS "result";        -- приведение строки к целому числу
    SELECT CAST(10 / 3.0 AS NUMERIC(5, 2)) AS "result"; -- приведение числа с плавающей точкой к числу с фиксированной точкой

Ограничение количества строк, возвращаемых запросом, осуществляется в соответствии со стандартом SQL:2008 использованием предложения :sql:`OFFSET x ROWS FETCH FIRST n ROWS ONLY`, где ``x`` -- смещение (номер первой строки выдачи), а ``n`` -- количество строк.

Пример:

.. code-block:: sql

    SELECT "name"
    FROM "student"
    WHERE "group_no" LIKE '4%'
    ORDER BY "date_of_birth"
    OFFSET 50 ROWS
    FETCH FIRST 10 ROWS ONLY;

В остальном (создание таблиц, запросы на чтение, изменение, добавление данных, использование группировки и агрегирующих функций) диалект SQL, используемый в PostgreSQL, практически не отличается от стандарта и большинства других СУБД.

Создание схемы базы данных и наполнение данными
===============================================

Для создания базы данных имеет смысл разработать скрипт, последовательно выполняющий сначала удаление объектов базы данных, а затем их создание. Таким путем можно легко и безболезненно производить регенерацию схемы базы данных, если в этом возникнет необходимость. Скрипт сохраняется в виде файла (чаще всего -- с расширением ``.sql``), и запускается на выполнение из командной консоли psql следующим образом:

.. code-block:: psql

    \i path_to_file/file_name.sql

Следует обратить внимание, что даже в операционной системе Windows косые черты должны быть прямыми, а не обратными, например ``C:/Users/student/Documents/db/generate.sql``.

В случае возникновения ошибок о них будет выведено сообщение в терминале psql, и после их исправления можно будет запустить выполнение файла повторно.

После создания схемы базы данных, полезно наполнить ее небольшим количеством тестовых данных, чтобы проверить корректность схемы и ограничений в ней, а в дальнейшем -- упростить проверку работы приложения. Это можно сделать с помощью выполнения команд ``INSERT`` в оболочке psql, но удобно было бы иметь возможность выполнять заполнение базы данных неоднократно, например, после регенерации схемы данных. Для достижения этого существует несколько вариантов.

#. Выполнение скрипта заполнения данными
   
   В данном случае операторы ``INSERT`` для таблиц базы данных помещаются в отдельный текстовый файл, а полученный скрипт запускается на выполнение командой, указанной выше в данном подразделе.

#. Импорт данных из CSV-файла
   
   CSV (comma-separated values, значения, разделенные запятыми) -- текстовый формат, предназначенный для хранения табличных данных. Файл в данном формате можно подготовить в текстовом редакторе, но удобнее делать это в табличном процессоре, например, в Excel. Для этого необходимо выбрать соответствующий формат при сохранении или экспорте файла. Следует знать, что в Европейских странах (и России в том числе) несмотря на название, в качестве разделителя значений в CSV-файле в Excel вместо запятой используется точка с запятой. Это продиктовано тем, что запятая в этих странах часто используется в качестве разделителя в записи дробных чисел и из-за этого не подходит для разделения значений.

   .. image:: ./img/excel.png

   .. image:: ./img/notepad.png

   После получения CSV-файла можно осуществить его импорт в предварительно созданную таблицу в базе данных путем выполнения следующей команды:

   .. code-block:: psql

       \copy table1(column1, column2, ...) FROM 'path_to_file' DELIMITER ';' CSV HEADER

   В приведенной команде ``table1(column1, column2, ...)`` -- описание таблицы, куда помещаются данные, ``FROM 'path_to_file'`` -- путь к CSV-файлу, ``DELIMITER ';'`` -- указание на то, что разделителем служит точка с запятой, ``CSV`` -- указание формата файла, ``HEADER`` -- указание, что первая строка файла содержит заголовки колонок (следует учесть, что заголовки в CSV-файле игнорируются и могут быть любыми, в том числе отсутствовать, при этом в команде импорта будет отсутствовать параметр ``HEADER``).

   Например, если таблица создана командой

   .. code-block:: sql
   
       CREATE TABLE "student" (
       "id"             INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
       "passport_no"    CHAR(11) UNIQUE, 
       "full_name"      VARCHAR(100), 
       "date_of_birth"  DATE
       );


   то команда импорта может выглядеть следующим образом:

   .. code-block:: psql
   
       \copy student(passport_no, full_name, date_of_birth) FROM 'C:/Users/student/db/data.csv' DELIMITER ';' CSV HEADER

   .. code-block:: sql
   
       SELECT * FROM "student";
       
::

         id | passport_no |  full_name   | date_of_birth
        ----+-------------+--------------+---------------
          1 | 1111 222222 | Иванов И.И   | 1999-02-01
          2 | 2222 333333 | Петров П.П.  | 2004-01-31
          3 | 3333 444444 | Сидоров С.С. | 1992-05-15
        (3 строки)

=======================
Создание веб-приложения
=======================

Создание виртуального окружения
===============================

Во многих современных языках программирования, опирающихся на использование большого количества библиотек, частью дистрибутива является средства управления пакетами. Для NodeJS такими средствами являются npm и yarn, для Ruby -- gem, для .NET -- NuGet, для Java -- Maven и Gradle, для PHP -- Composer. Их назначением является установка, удаление, обновление зависимостей проекта (библиотек, не являющихся частью стандартной поставки языка), а также управление версиями этих зависимостей. Для языка Python существует несколько инструментов, которые выполняют аналогичные функции. В этом разделе будут рассмотрены стандартные утилиты, входящие во многие дистрибутивы языка Python -- менеджер пакетов pip, а также средство управления виртуальными окружениями venv.

Управление зависимостями решает проблемы, связанные с тем, что в одной и той же операционной системе могут разрабатываться различные проекты, использующие сторонние библиотеки. Довольно часто множества таких зависимостей для разных проектов пересекаются, то есть различным проектам необходимы одни и те же библиотеки. Потенциально это может привести к проблемам, когда независимый разработчик библиотеки внес в новую версию некоторые изменения, и установка последней версии библиотеки может вызвать неработоспособность проектов, зависящих от более старой его версии.

Хорошей практикой считается не устанавливать зависимости глобально для всех проектов, а создавать для каждого проекта так называемое "виртуальное окружение" -- изолированное пространство, которое может содержать среду выполнения Python определенной версии, а также те версии тех зависимостей, которые будут установлены туда пользователем. Виртуальное окружение будет изолировано от виртуальных сред других проектов и от глобальной установки Python. Для управления виртуальным окружением не требуются права администратора. Помимо прочего, менеджер зависимостей предоставляет инструменты для репликации виртуального окружения, то есть воссоздания всех зависимостей, к примеру, при развертывании проекта на другой системе.

Вызов интерпретатора Python может производиться по-разному в различных операционных системах:

.. code-block:: bash

    python      # Windows, Linux, MacOS
    python3     # Linux
    py          # Windows

В дальнейшем в данном пособии будет использоваться вызов интерпретатора командой ``python``.

В некоторых дистрибутивах Linux устанавливать pip и venv необходимо вручную. Для проверки, установлен ли стандартный менеджер пакетов Python в системе, можно воспользоваться командой 

.. code-block:: bat

    python -m pip --version

В случае, если менеджер пакетов не установлен, команда завершается с ошибкой. Также полезной является команда

.. code-block:: bat

    python -m pip list

Эта команда выводит в консоль список всех установленных в текущем окружении пакетов. По умолчанию будет выведены пакеты, установленные глобально. 

Для создания виртуального окружения, необходимо, находясь в каталоге проекта, выполнить команду

.. code-block:: bat

    python -m venv env_name

В вышеприведенной команде ``venv`` -- имя стандартного модуля для управления виртуальными окружениями, ``env_name`` -- имя создаваемого виртуального окружения. В текущем каталоге будет создан подкаталог, куда будет помещено содержимое виртуального окружения. Например, для создания виртуального окружения с именем ``venv``, необходимо выполнить команду


.. code-block:: bat
    
    python -m venv venv

Необходимо понимать, что подкаталог ``venv`` с виртуальным окружением будет создан в текущем каталоге. Если необходимо другое поведение, есть возможность использовать абсолютный путь:

.. code-block:: bat

    python -m venv C:\Users\student\myproject\venv

Для "включения" нового окружения его необходимо активировать. В Windows:

.. code-block:: bat

    venv\Scripts\activate

В Linux:

.. code-block:: bash

    source venv/bin/activate

Во время работы с окружением в приглашении командной строки будет отображаться его имя.

Чтобы деактивировать окружение, нужно выполнить команду

.. code-block:: bat

    deactivate

Если выполнить команду :bat:`pip list`, находясь в виртуальном окружении, то выдача должна быть практически пустой, даже если глобально было установлено большое количество пакетов.

Установка пакета производится командой

.. code-block:: bat

    python -m pip install package_name

При этом пакет устанавливается в активное виртуальное окружение (или глобально, если ни одно виртуальное окружение не активно). 

Описание виртуального окружения для возможности его воссоздания принято хранить в текстовом файле ``requirements.txt``, который описывает все зависимости и их версии (при необходимости). Этот файл можно создать вручную, но удобнее делать это с помощью команды 

.. code-block:: bat

    python -m pip freeze > requirements.txt

Для воссоздания виртуального окружения необходимо выполнить команду

.. code-block:: bat

    python -m pip install -r requirements.txt

Она выполняет установку каждой из перечисленных в файле ``requirements.txt`` зависимостей в текущее виртуальное окружение.

Следует подчеркнуть, что виртуальное окружение как правило не принято помещать под контроль версий. Вместо этого обычно в репозиторий помещают его описание в файле ``requirements.txt``, а каталог с виртуальным окружением добавляют в файл ``.gitignore``.

Создание базового веб-приложения
================================

Чаще всего в промышленной веб-разработке используются фреймворки -- специализированные библиотеки, предоставляющие готовые типовые архитектурные решения и избавляющие от необходимости реализации базовых, низкоуровневых или типичных функций (например, разбор HTTP-запросов, формирование HTTP-ответов, управление cookie, работа с сессиями).

Flask -- фреймворк, использующийся для создания веб-приложений на Python. Его отличительными особенностями являются минималистичность и гибкость в выборе структуры проекта. Минималистичность, то есть отсутствие широкого функционала, встроенного непосредственно в сам фреймворк, компенсируется расширяемостью за счет сторонних библиотек и плагинов. Так, отсутствующий в составе Flask средство объектно-реляционного отображения может быть заменено использованием библиотек Pony или SQLAlchemy, а отсутствие возможности сгенерировать интерфейс администратора -- подключением плагина Flask-Admin. Гибкость же проявляется в том, что разработчик обязан самостоятельно принять большое количество технических решений в процессе проектирования архитектуры приложения, выбора технологий и библиотек. Такой подход также хорошо подходит для обучения, поскольку не загромождает изучение приемов разработки большим количеством технологий, идущих "в нагрузку" к фреймворку.

Для установки Flask необходимо в каталоге проекта активировать виртуальное окружение и выполнить команду

.. code-block:: bat

    python -m pip install flask

Одним из архитектурных решений, которое необходимо принять, является выбор структуры проекта. Для небольших проектов подходит типовое решение в виде модуля, когда приложение представляет собой одиночный файл (собственно, модуль), содержит всю его логику. Для более крупных приложений имеет смысл сделать выбор в пользу типового решения в виде пакета.

Пакет в Python -- каталог, который содержит иерархическую структуру файлов с исполняемым кодом и специальный файл с именем ``__init__.py``, несущий в себе программный код, исполняемый при импорте пакета. Таким образом мы получаем возможность структурировать проект, разбив его на несколько файлов и поместив их в подкаталог, вмещающий в себя все приложение.

Файловая структура проекта на начальном этапе может иметь такой вид:

::

    myproject/
    ├─ app/
    │  ├─ __init__.py
    │  ├─ routes.py
    ├─ venv/
    │  ├─ ...
    ├─ .gitignore
    ├─ myproject.py
    ├─ requirements.txt
    ├─ start.sh

Здесь ``app`` -- имя пакета, содержащего приложение, ``myproject.py`` -- файл для запуска приложения (импортирования пакета с приложением), ``start.sh`` -- скрипт командного интерпретатора для комфортного запуска приложения (в Windows должен иметь название ``start.bat``).

Содержимое файла ``myproject.py``:

.. code-block:: python

    from app import app

Содержимое файла ``__init__.py``:

.. code-block:: python

    from flask import Flask
    app = Flask(__name__)

    from app import routes

Здесь происходит импорт класса Flask и его инстанцирование в виде объекта ``app``, а также импортирование представлений, расположенных в файле ``routes.py``.

Файл ``routes.py`` составляет важнейшую часть веб-приложения и содержит так называемые представления (views) -- обработчики событий, запускающиеся при поступлении запросов от клиента к тем или иным URL в приложении. Сопоставление URL с представлениями называется маршрутизацией и является одной из основных функций Werkzeug -- библиотеки, на которой основан Flask. Следует отметить, что имя этого и большинства остальных файлов проекта может быть произвольным (Flask не накладывает ограничений на именование компонентов проекта), но желательно делать его адекватным и соответствующим конвенциям об именованиях [#pep8]_. Например, подходящим именем для файла с представлениями могло бы быть ``views.py``.

Представления реализуются в виде функций Python, к которым применены декораторы ``route``, ``get`` или ``post``. Параметром декоратора является строка -- маршрут, поступление запроса на который должно быть обработано данным представлением.

Содержимое файла ``routes.py``:

.. code-block:: python

    from app import app

    @app.route('/')
    def hello_world():
        return "Hello, World!"

Возвращаемое значение функции в данном случае является строкой, которая будет передана клиенту в ответ на запрос по URL ``'/'``, то есть к корневому адресу веб-приложения. В общем же случае возвращаться могут данные разных типов, подобно тому как в качестве содержимого ответа HTTP могут быть веб-страница, перенаправление, документ JSON и т.д. В настоящем пособии наиболее частым видом ответа (и соответственно возвращаемого значения функции-представления) будет веб-страница.

Представление, созданное с помощью декоратора ``route``, может обрабатывать и GET-, и POST-запросы (по умолчанию обрабатываются только GET-запросы, для обработки POST-запросов необходимо указать параметр ``methods`` декоратора), при этом в логике представления могут содержаться различные варианты действий в зависимости от типа запроса:

.. code-block:: python

    from flask import request
    from app import app

    @app.route('/', methods=['GET', 'POST'])
    def index():
        if request.method == 'GET':
            return 'Hello, World!'
        elif request.method == 'POST':
            return 'Hello, World! (POST-запрос)'
        else:
            return 'Неизвестный метод запроса'

При использовании декораторов ``get`` или ``post`` представление становится специализированным только для конкретного метода запросов.

Объект ``request`` является глобальным и представляет собой довольно сложный объект, содержащий информацию о HTTP-запросе, включающую в себя помимо метода заголовки запроса, тело запроса, параметры, переданные в URL и прочее. Он будет использован и в дальнейшем в данном пособии.

В примере выше представление переименовано в ``index``, что соответствует общепринятой в веб-разработке практике именования ресурсов, возвращаемых по умолчанию (в данном случае -- при обращении к корневому адресу).

.. [#pep8] https://peps.python.org/pep-0008/#naming-conventions

Запуск сервера разработки
=========================

Для запуска приложения необходим веб-сервер. В его функции входит обслуживание сетевых подключений, получение запросов и отправка ответов. Веб-приложение, которое пишет разработчик, обязано разбирать запросы и формировать ответы на них. 

Веб-приложения, написанные на Python, должны следовать стандарту WSGI (Web Server Gateway Interface) или одному из его альтернатив (например, ASGI, Asynchronous Server Gateway Interface). Это необходимо для того, чтобы соблюдался некоторый протокол взаимодействия фреймворков (например, Flask, Django) с веб-серверами (nginx, Apache). При этом веб-сервер должен понимать, как и в какой форме передать коду на Python содержимое HTTP-запроса и как принять от него данные ответа, а само веб-приложение обязано предоставить вызываемый объект, принимающий данные запроса и возвращающий ответ. Спецификация WSGI [#wsgi]_ описывает детали этого взаимодействия. А фреймворк Flask построен на базе Werkzeug -- WSGI-библиотеки, реализующей данный протокол взаимодействия. Таким образом, приложения на Python могут взаимодействовать с веб-серверами.

Со стороны сервера также требуется поддержка протокола WSGI. Для серверов, которые не привязаны к языку Python, чаще всего это реализовано с помощь плагинов или дополнительных прослоек (например, mod_wsgi для Apache, Gunicorn для nginx).

На этапах разработки запуск возможен на встроенном в Flask (а точнее -- в Werkzeug) простом веб-сервере. Он поддерживает WSGI, не требует настройки, но не рекомендуется для использования в условиях промышленного применения приложения ввиду своей недостаточной эффективности и безопасности. В разделе, посвященном развертыванию веб-приложения будет освещены детали использования альтернативных веб-серверов.

Для запуска приложения на встроенном веб-сервере можно воспользоваться командой ``flask run``. Она попытается самостоятельно найти экземпляр приложения (имя модуля и имя объекта Flask в нем), но имеет смысл сделать это явно с помощью параметра ``--app``:

.. code-block:: bash

    python -m flask --app myproject:app run --port port_no

В приведенной команде ``myproject:app`` -- указание на объект ``app`` в модуле ``myproject.py``, ``port_no`` -- номер порта, на котором запускается приложение. По умолчанию (если не указана опция ``--port``) запуск происходит на порту 5000.

Для удобства можно создать файл ``start.sh`` (``start.bat`` в Windows), который будет осуществлять запуск сервера данной командой.

Если в веб-приложении, развернутом в промышленных условиях, происходит ошибка, то клиенту возвращается малоинформативный результат (например, страница ошибки с кодом состояния ``500 Internal Server Error``). Как правило, это делается умышленно, поскольку владелец веб-приложения чаще всего заинтересован в том, чтобы клиент знал о деталях ошибки как можно меньше и не воспользовался некоторой уязвимостью. Напротив, в период разработки чрезвычайно удобным является режим, когда детальная информация об ошибке возвращается клиенту (которым является сам разработчик) в виде веб-страницы. Для этого в Flask существует специальный режим, который включается следующим образом:

.. code-block:: bash

    python -m flask --app myproject:app run --debug

Что также удобно, в данном режиме Flask перезапускает веб-сервер каждый раз, когда меняется исходный код приложения, и нет необходимости делать это вручную.

При запуске на локальном компьютере веб-приложение будет отдавать строку ``"Hello, World!"`` при запросе по адресу ``http://localhost:5000/``. Проверить это можно с помощью браузера или утилит curl, Wget, Postman и других.

.. [#wsgi] https://peps.python.org/pep-3333/

Конфигурирование приложения
===========================

Любому приложению требуется та или иная конфигурация. В случае веб-приложения опциями конфигурации могут быть включение или отключение отладки, адреса сервисов и ресурсов, таких как база данных, очередь сообщений, кэш, учетные данные для доступа к этим сервисам или ресурсам, различные способы развертывания для условий разработки и условий реального применения и так далее.

Flask спроектирован так, что настройки конфигурации хранятся в словаре ``config``, являющимся атрибутом объекта Flask (в примерах в данном пособии объект носит имя ``app``). Некоторыми элементами словаря управляет сам Flask, при этом разработчик может создавать свои атрибуты и использовать их в любом месте приложения.

Очевидным решением представляется хранение таких настроек в коде, например, в модуле ``config.py``:

.. code-block:: python

    class Config(object):
        SECRET_KEY = '336c8e1b3598c552b1b672b42e1271d04357c3a09d550eb83c609b512acc875b'
        DB_SERVER = 'localhost'

При инициализации приложения можно загрузить конфигурацию следующим образом (файл ``__init__.py``):

.. code-block:: python

    from flask import Flask
    from app.config import Config

    app = Flask(__name__)
    app.config.from_object(Config)

    from app import routes


После этого в приложении можно получить доступ к его параметрам конфигурации путем обращения к словарю ``app.config``:

.. code-block:: python

    print(app.config['DB_SERVER'])  # localhost

При этом возникают две серьезные проблемы.

Первая проблема заключается в том, что конфигурации могут (и скорее всего будут) различаться для development-сервера (развертывания, которое использует разработчик на своем компьютере для отладки кода во время его написания) и production-сервера (развертывания, используемое на сервере, к которому подключаются пользователи приложения). Вариантов развертывания в реальных условиях может быть больше, чем два, например, может существовать staging-сервер (промежуточное развертывание для тестирования в условиях, близких к production).

Считается плохой практикой хранить такие настройки в коде приложения, поскольку в этом случае на разных развертываниях будет различный код, что существенно повысит вероятность ошибок и путаницы. При этом необходим механизм, позволяющий без труда и желательно автоматически применять те или иные конфигурации в зависимости от типа развертывания. К сожалению, единого универсального подхода, который учитывал бы все возможные нюансы, не существует. Решению данной проблемы посвящена отрасль, называемая управлением конфигурациями, и существуют инструменты [#dynaconf]_ и методологии [#12factor]_, которые этим занимаются.

Второй проблемой является то, что часть опций конфигурации представляют собой чувствительные данные (например, пароли, API-токены, приватные ключи). Такого рода опции называют секретами, и их нельзя помещать в систему управления версиями, поскольку они останутся в ней навсегда и могут стать доступны людям, не имеющим на это прав. Данная задача называется управлением секретами и является частным случаем управления конфигурациями. К сожалению, универсального решения данной проблемы также не существует [#secrets]_.

Даже в масштабах небольшого приложения, разработка которого рассматривается в данном пособии, невозможно игнорировать две эти проблемы, и далее будет предложена одна из возможных схем для этого.

Идея заключается в том, чтобы избавиться от настройки параметров конфигурации внутри кода приложения (например, файла ``config.py``), и перенести эти параметры в переменные окружения операционной системы [#12factor]_, то есть привязать к конкретному серверу, на котором необходимо исполнять приложение.

Переменные окружения можно устанавливать вручную из терминала операционной системы:

.. code-block:: bash

    export MY_VAR=1   # Linux, MacOS
    set MY_VAR=1      # Windows

а затем считывать из кода приложения на Python:

.. code-block:: python

    import os
    print(os.environ.get('MY_VAR'))  # 1

В этом случае файл ``config.py`` может иметь следующий вид:

.. code-block:: python

    import os
    
    class Config(object):
        SECRET_KEY = os.environ.get('SECRET_KEY')
        DB_SERVER = os.environ.get('DB_SERVER')

Так решаются сразу две проблемы: 

* теперь код для различных развертываний один и тот же, а конкретные настройки поступают в приложение из операционной системы,
* чувствительные параметры (секреты) не хранятся в репозитории системы управления версиями и не могут быть скомпрометированы.
  
Остается определить, как значения параметров конфигурации попадут в переменные окружения операционной системы на всех развертываниях, где предполагается выполнение приложения. Значения переменных окружения сбрасываются каждый раз при запуске нового сеанса терминала и при перезагрузке сервера, поэтому их установка вручную совершенно непрактична.

Одним из вариантов решения задачи является использование специальных файлов окружения ``.env``, которые содержат значения для записи в переменные окружения, причем сама эта запись может осуществляться автоматически. Для этого потребуется библиотека ``python-dotenv``. Из виртуального окружения следует выполнить:

.. code-block:: bash

    python -m pip install python-dotenv

После этого файл ``config.py`` для записи значений переменных окружения из файла ``.env`` и наполнения объекта конфигурации из переменных окружения может иметь вид:

.. code-block:: python

    import os
    from dotenv import load_dotenv
    
    load_dotenv()

    class Config(object):
        SECRET_KEY = os.environ.get('SECRET_KEY')
        DB_SERVER = os.environ.get('DB_SERVER')

Сам файл ``.env`` имеет следующий синтаксис:

.. code-block:: bash

    # Development settings
    SECRET_KEY=336c8e1b3598c552b1b672b42e1271d04357c3a09d550eb83c609b512acc875b
    DB_SERVER=localhost

Следует подчеркнуть, что файл ``.env`` и другие файлы окружения, если они есть, ни при каких обстоятельствах не должны помещаться в систему контроля версий, вместо этого управление ими должно быть отделено от сборки приложения и выполняться на этапе развертывания.

Может также возникнуть проблема отсутствия файла окружения, например, если разработчик только что скачал кодовую базу из репозитория. В этом случае уместно предусмотреть какую-то конфигурацию по умолчанию, которая хранится в коде (то есть в репозитории) и в которой отсутствуют секреты. К примеру, файл ``config.py`` может выглядеть следующим образом:

.. code-block:: python

    import os
    from dotenv import load_dotenv
    
    load_dotenv()

    class Config(object):
        SECRET_KEY = os.environ.get('SECRET_KEY') or 'abcde'
        DB_SERVER = os.environ.get('DB_SERVER') or 'localhost'

В этом случае если в переменных окружения не окажется значения (например, в силу отсутствия файла ``.env``), то соответствующим параметрам будут присвоены значения по умолчанию.

Файловая структура проекта после добавления конфигурации может принять следующий вид:

::

    myproject/
    ├─ app/
    │  ├─ __init__.py
    |  ├─ config.py
    │  ├─ routes.py
    ├─ venv/
    │  ├─ ...
    ├─ .env
    ├─ .gitignore
    ├─ myproject.py
    ├─ requirements.txt
    ├─ start.sh

.. [#dynaconf] https://www.dynaconf.com/flask/
.. [#12factor] https://12factor.net/ru/config
.. [#secrets] https://blog.envkey.com/managing-passwords-and-secrets-common-anti-patterns-2d5d2ab8e8ca

Подключение к базе данных и выполнение запросов
===============================================

Для подключения к PostgreSQL в стандартной библиотеке Python нет встроенных средств, но это компенсируется наличием широко распространенной библиотеки psycopg [#psycopg]_, которая придерживается стандарта DB-API [#dbapi]_. Данный факт означает, что ее интерфейс будет схож с другими адаптерами для баз данных языка Python, например встроенного адаптера sqlite3.

Для установки psycopg необходимо внутри виртуального окружения выполнить команду:

.. code-block:: bash

    python -m pip install psycopg

После этого появится возможность осуществлять подключение к базе данных и выполнять запросы в коде программы.

Перед тем, как рассмотреть работу с библиотекой psycopg полезно убедиться, что имеется понимание принципов работы с транзакциями (что является базовым требованием к читателю настоящего пособия), а также представление о функциональности классов ``Connection`` и ``Cursor``, описанной в стандарте DB-API [#dbapi]_ и реализованной в psycopg.

Объект ``Connection`` представляет собой экземпляр подключения к базе данных, который позволяет выполнять запросы и получать их результаты. Его можно в некоторой степени отождествить с сессией работы с базой данных при использовании утилиты psql, за исключением того, что объект ``Connection`` способен автоматически управлять транзакциями. Объект ``Connection`` создается функцией ``connect``, которая принимает в качестве аргумента строку подключения к базе данных -- строковый объект, содержащий параметры, используемые для подключения.

Строка подключения для psycopg может иметь два варианта представления:

* Набор пар ``ключ=значение``, например ``"host=localhost port=5432 dbname=mydb connect_timeout=10"`` 
* URI подключения (с синтаксисом согласно стандарту RFC 3986 [#uri]_), например ``"postgresql://localhost:5432/mydb?connect_timeout=10"``
   
Альтернативой при вызове метода ``connect`` может быть использование именованных аргументов, список которых совпадает со списком параметров, задаваемых в строке подключения. Ниже перечислены некоторые из возможных аргументов. 

:host: имя хоста
:port: номер порта
:user: имя пользователя
:password: пароль
:dbname: имя базы данных
:connect_timeout: максимальное количество секунд, в течение которого клиент ожидает ответа от сервера, после чего прекращает попытку подключения

Например, следующее представление тестирует подключение к базе данных:

.. code-block:: python

    from app import app
    import psycopg

    @app.route('/testdb')
    def test_connection():
        con = None
        message = ""
        try:
            con = psycopg.connect(host=app.config['DB_SERVER'], 
                                  user=app.config['DB_USER'], 
                                  password=app.config['DB_PASSWORD'],
                                  dbname=app.config['DB_NAME'])
        except Exception as e:
            message = f"Ошибка подключения: {e}"
        else:
            message = "Подключение успешно"
        finally:
            if con:
                con.close()
            return message

Метод ``close`` закрывает подключение к базе данных.

Часто объект ``Connection`` используется как менеджер контекста:

.. code-block:: python
    
    with psycopg.connect(host=app.config['DB_SERVER'], ...) as con:
        # здесь производятся действия с подключением

После выхода из ``with``-блока объект ``Connection`` осуществляет фиксацию всех транзакций в случае, если не было исключений, либо их откат, если исключения возникли. Также, вне зависимости от возникновения исключений, после выхода из ``with``-блока закрывается само подключение.

.. [#dbapi] https://peps.python.org/pep-0249/
.. [#psycopg] https://www.psycopg.org/
.. [#uri] https://datatracker.ietf.org/doc/html/rfc3986

С помощью подключения можно создавать курсоры -- объекты класса ``Cursor``, позволяющие посылать команды базе данных и облегчающие обработку результатов. В общем случае в пределах одного подключения можно создать несколько курсоров, но два и более курсоров в одном подключении не способны выполнять операции одновременно, поэтому если необходим параллелизм, имеет смысл использовать курсоры в различных подключениях.

Следует отметить, что по умолчанию psycopg создает клиентские курсоры, то есть те, которые хранятся на стороне клиента и при выполнении запроса на выборку получают сразу все данные ответа и загружают их в память клиента. Разумеется, под клиентом в данном случае понимается приложение на Python, которое является клиентом по отношению к серверу базы данных. Альтернативой являются серверные курсоры, которые хранятся на сервере и получают данные не сразу же при выполнении запроса, а по мере итерирования по ним, возвращая данные клиенту небольшими порциями. Использование серверных курсоров позволяет обрабатывать чрезвычайно большие объемы данных, которые могут не поместиться в память клиента, но для работы с небольшими объемами данных клиентские курсоры более предпочтительны, поскольку получение их результата происходит немного быстрее за счет отсутствия избыточного взаимодействия с сервером.

Для создания курсора может быть использован метод объекта подключения ``cursor``. После этого становится доступен метод курсора ``execute``, использующийся для выполнения запроса к базе данных, принимающий в качестве аргумента запрос и его параметры и возвращающий сам объект курсора.

.. code-block:: python

    cur = con.cursor()
    cur.execute('SELECT * FROM my_table')

Также курсор может быть создан неявно, если вызвать метод подключения ``execute``. При этом у созданного курсора вызывается его метод ``execute``:

.. code-block:: python

    cur = con.execute('SELECT * FROM my_table')

Если запрос возвращает некоторые данные, то из них формируется набор записей, и объект курсора позволяет итерировать по ним с помощью методов ``fetchone``, ``fetchmany`` и ``fetchall``. При этом ``fetchone`` возвращает кортеж, соответствующий следующей одиночной записи, либо ``None``, если набор записей пуст, ``fetchmany`` -- массив кортежей из указанного максимального количества следующих записей (либо пустой массив, если набор записей пуст), ``fetchall`` -- массив кортежей из всех оставшихся записей набора (либо пустой массив, если набор записей пуст).

Например, пусть в базе данных есть таблица ``t1`` следующего вида:

=== === ===
 A   B   C
=== === ===
 1   2   3
 4   5   6
 7   8   9
 9   8   7
 6   5   4
 3   2   1
=== === ===

Тогда возможно следующее получение данных с помощью курсора:

.. code-block:: python

    with psycopg.connect(...) as con:
        cur = con.cursor()
        cur.execute('SELECT * FROM t1')
        print(cur.fetchone())                   # (1, 2, 3)
        print(cur.fetchmany(2))                 # [(4, 5, 6), (7, 8, 9)]
        print(cur.fetchall())                   # [(9, 8, 7), (6, 5, 4), (3, 2, 1)]
        print(cur.fetchone())                   # None
        print(cur.fetchall())                   # []

Поскольку метод ``execute`` возвращает объект курсора, а курсор поддерживает итерирование по результирующему набору записей, можно использовать это для написания более простого кода:

.. code-block:: python

    with psycopg.connect(...) as con:
        cur = con.cursor()
        for row in cur.execute('SELECT * FROM t1'):
            print(f'{row[0]} - {row[1]} - {row[2]}')

В данном примере на каждой итерации по отдельности выводятся все три элемента кортежа ``row``.

Стоит подчеркнуть, что даже если запрос возвращает один столбец, то результатом метода ``fetchone`` будет кортеж из одного элемента, а методов ``fetchmany`` и ``fetchall`` -- массив кортежей из одного элемента. Для использования этих значений также потребуется доступ по индексу.

.. code-block:: python

    with psycopg.connect(...) as con:
        cur = con.cursor()
        client_names = cur.execute('SELECT name FROM client').fetchall()
        for name in client_names:               # [(Иванов,), (Петров,), (Сидоров,)]
            print(f'Имя клиента: {name[0]}')

Чаще всего бывает необходимо параметризовать запрос к базе данных, используя какие-то данные из программы. Например, вывести имена не всех клиентов, а только клиентов из города, который интересен пользователю. В этом случае возникает желание вставить в строку запроса значение переменной, которую мы хотим использовать в качестве параметра.

.. code-block:: python
    
    client_city = input()
    with psycopg.connect(...) as con:
        cur = con.cursor()
        client_names = cur.execute(f'SELECT name FROM client WHERE city LIKE {client_city}').fetchall()
        # you are already hacked

Так делать нельзя ни при каких обстоятельствах, поскольку это порождает серьезную уязвимость приложения, позволяющую использовать SQL-инъекции [#sqlinjection]_ для несанкционированного доступа к данным в базе данных.

.. [#sqlinjection] https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_SQL-%D0%BA%D0%BE%D0%B4%D0%B0

Следующие варианты также недопустимы:

.. code-block:: python
    
    client_names = cur.execute('SELECT name FROM client WHERE city LIKE %s' % client_city).fetchall()
    client_names = cur.execute('SELECT name FROM client WHERE city LIKE ' + client_city).fetchall()

Проблема в том, что данные, получаемые извне (в примере выше -- значение переменной ``client_city``), могут содержать зловредный SQL-код, который будет исполнен и может повлечь утечку данных или их повреждение.

Чтобы этого избежать, необходимо передавать значения параметров запроса вторым аргументом функции ``execute``, при этом сам запрос и его параметры передаются на сервер раздельно, и их связывание происходит на сервере перед выполнением. Так работает механизм подготовленных операторов, когда запрос разбирается отдельно от параметров, хранится на сервере и может быть выполнен с разными значениями параметров. В такой схеме параметры не разбираются и не могут быть выполнены как часть кода запроса. 

При этом параметры запроса могут быть позиционными (внедряются в запрос однократно в том порядке, в котором перечислены), либо именованными.

Позиционные параметры могут быть переданы в виде кортежа или массива:

.. code-block:: python
    
    cur.execute('INSERT INTO t1 (A, B, C) VALUES (%s, %s, %s)', (10, 20, 30))
    cur.execute('INSERT INTO t1 (A, B, C) VALUES (%s, %s, %s)', [40, 50, 60])

Именованные параметры передаются в виде словаря:

.. code-block:: python
    
    cur.execute('INSERT INTO t1 (A, B, C) VALUES (%(foo)s, %(bar)s, %(bar)s)', 
                {'foo': 70, 'bar': 80})

Если параметр у запроса всего один, он все равно должен быть передан в виде кортежа, массива или словаря:

.. code-block:: python
    
    client_names = cur.execute('SELECT name FROM client WHERE city LIKE %s', (client_city,)).fetchall()
    client_names = cur.execute('SELECT name FROM client WHERE city LIKE %s', [client_city]).fetchall()
    client_names = cur.execute('SELECT name FROM client WHERE city LIKE %(cc)s', {'cc': client_city}).fetchall()

При выполнении операций, выполняющих изменения данных (``INSERT``, ``UPDATE``, ``DELETE``), необходимо учитывать поведение библиотеки psycopg в части управления транзакциями.

По умолчанию первая выполняемая с базой данных операция (в том числе ``SELECT``) в рамках подключения начинает новую транзакцию. Как следствие, изменения, производимые в данном подключении, не видны за пределами этого подключения до выполнения фиксации, а также могут быть отменены выполнением отката. Фиксация вручную осуществляется методом ``commit``, а откат -- методом ``rollback``.

В случае, если объект подключения создавался в рамках ``with``-блока, при выходе из него, фиксация выполняется автоматически.

Наоборот, если ``with``-блок не используется, а подключение было закрыто явно (методом ``close``), либо завершилась функция, в которой оно было создано, но явной фиксации (методом ``commit``) не было, транзакция автоматически откатывается.

.. code-block:: python

    con = psycopg.connect(...)
    cur = con.cursor()
    cur.execute('SELECT a FROM my_table') # начало транзакции
    cur.execute('INSERT INTO my_table ... VALUES ...')
    con.close() # не было con.commit(), выполняется откат

Работа с шаблонами
==================

В качестве ответа приложения на запрос клиента, как правило, требуется сформировать текст в некотором формате, например, страницу в формате HTML. Разумеется, содержимое текста ответа должно быть сформировано динамически, часто -- на основе данных из базы данных. Для этих целей удобно иметь средства, позволяющие встраивать в крупные текстовые объекты значения из программы, а также реализующие некоторые несложные языковые средства, такие как ветвления, циклы, приведения типов, отладка и прочие. В составе фреймворка Flask есть инструмент, который реализует эти требования -- движок шаблонов Jinja. Следует отметить, что вместо него может быть использован какой-либо другой шаблонизатор, равно как и наоборот, Jinja может быть использован вне проектов Flask.

Основная мотивация использования шаблонизатора -- отделение логики от представления, а конкретно -- кода Python, выполняющего какую-то бизнес-логику (и, возможно, доступ к данным) от кода HTML, содержащего логику визуального отображения работы приложения. Разделение этих частей приложения ведет к более качественной организации каждой из них и является частным случаем универсальной идиомы отделения представления от содержания, находящей применение не только в разработке ПО.

Согласно принципам работы Jinja, создается специальный каталог, содержащий шаблоны (по умолчанию -- каталог ``templates`` в каталоге приложения) -- текстовые файлы, содержащие разметку целевого языка (в нашем случае HTML) с внедренными конструкциями языка шаблонизатора.

Вызов механизма рендеринга шаблона осуществляется с помощью функции ``render_template``, которая принимает в качестве первого аргумента название шаблона, а также позволяет передавать именованные аргументы, значения которых можно отображать в тексте результирующего ответа, причем поддерживаются любые структуры данных Python.

Например, данное представление может получать из базы данных информацию о клиентах из Санкт-Петербурга и вызывать рендеринг шаблона для отображения этой информации клиенту, передавая в качестве параметров заголовок страницы и список имен клиентов:

.. code-block:: python

    from app import app
    from flask import render_template
    import psycopg

    @app.route('/spb_clients')
    def get_spb_clients():
        client_city = 'Санкт-Петербург'
        with psycopg.connect(host=app.config['DB_SERVER'], 
                             user=app.config['DB_USER'], 
                             password=app.config['DB_PASSWORD'],
                             dbname=app.config['DB_NAME']) as con:    
            cur = con.cursor()
            client_names = cur.execute(f'SELECT name FROM client WHERE city LIKE %s',
                                       (client_city,)).fetchall()
            return render_template('clients.html', title='Клиенты из Санкт-Петербурга',
                                   client_names=client_names)

Простейший шаблон для отображения информации о клиентах ``clients.html`` может выглядеть следующим образом:

.. code-block:: jinja

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            <title>{{ title }}</title>
        </head>
        <body>
            <h2>{{ title }}</h2>
            {% if client_names|length == 0 %}
                <p>Клиентов не найдено.</p>
            {% else %}
                <table>
                    <thead>
                        <tr>
                            <th>№</th>
                            <th>ФИО</th>
                        </tr>
                    </thead>
                    <tbody>
                    {% for client_name in client_names %}                    
                        <tr>
                            <td>{{ loop.index }}</td>
                            <td>{{ client_name[0] }}</td>
                        </tr>
                    {% endfor %}
                    </tbody>
                </table>
            {% endif %}
        </body>
    </html>

В этом примере стоит обратить внимание на то, как используются двойные фигурные скобки ``{{ ... }}`` для рендеринга значений объектов кода приложения. В некотором роде это можно считать аналогом функции ``print`` для шаблонов. Некоторые объекты, с которыми имеет дело код шаблонизатора, а именно строка ``title`` и массив кортежей ``client_names`` были переданы именованными аргументами функции ``render_template``. Управляющие конструкции развилки и цикла используют синтаксис ``{% ... %}`` и имеют парные закрывающие элементы. Также пример содержит иллюстрацию типичной схемы работы с массивом -- проверка на пустоту и итерирование по элементам с выводом номера итерации (``loop.index``). ``client_name[0]`` означает обращение к нулевому элементу кортежа -- строке, содержащей имя клиента.

На текущий момент структура каталогов веб-приложения может иметь следующий вид:

::

    myproject/
    ├─ app/
    |  ├─ templates/
    │  |  ├─ clients.html
    │  ├─ __init__.py
    |  ├─ config.py
    │  ├─ routes.py
    ├─ venv/
    │  ├─ ...
    ├─ .env
    ├─ .gitignore
    ├─ myproject.py
    ├─ requirements.txt
    ├─ start.sh

В типичном веб-приложении может быть много шаблонов, отвечающих за различные страницы. Соответственно для каждого из них необходимо будет создать файл в каталоге ``templates``. При этом нетрудно догадаться, что некоторая часть содержимого всех шаблонов будет одинаковой, к примеру элемент ``head`` с подключением необходимых стилей и библиотек, возможно какие-то элементы навигации (логотип, ведущий на главную страницу, ссылка на профиль пользователя, страницу выхода, страницу информации о компании и так далее). Движок шаблонов Jinja позволяет вынести весь многократно используемый код в отдельный шаблон и позволить остальным шаблонам включать этот код без необходимости его повторения. Такое включение называется наследованием и может быть многоуровневым (к примеру, все страницы веб-приложения наследуют базовый шаблон, а страницы, относящиеся к карточкам товаров, наследуют шаблон карточки, который в свою очередь наследует базовый).

К примеру, можно создать шаблон ``base.html``, содержащий повторяющийся код:

.. code-block:: jinja

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            {% if title %}
                <title>{{ title }}</title>
            {% else %}
                <title>Добро пожаловать</title>
            {% endif %}
        </head>
        <body>
            <div><a href="{{ url_for('index') }}">Главная</a></div>
            <hr>
            {% block content %}{% endblock %}
        </body>
    </html>

Операторы ``block`` и ``endblock`` ограничивают в шаблоне те части, куда будет внедряться содержимое шаблона, который наследуется от ``base.html``. Таких частей может быть несколько, и они все имеют имена (в данном примере -- ``content``). Шаблоны-наследники могут предоставлять или не предоставлять содержимое для этих блоков.

В примере выше также используется функция Flask ``url_for``, возвращающая URL, обрабатываемый представлением, имя которого передано ей в качестве аргумента. Сгенерированный URL используется в атрибуте ``href`` для создания ссылки. Данный способ по ряду причин является более предпочтительным по сравнению с ручным указанием URL в коде шаблона:

* Адресация с помощью URL может измениться, и в этом случае функция ``url_for`` вернет актуальный URL на основании параметра декоратора представления. В противном случае возникла бы необходимость изменять все URL вручную в коде шаблонов.
* ``url_for`` поддерживает передачу аргументов представлению, в этом случае URL будет сформирован с учетом этих аргументов
* ``url_for`` удобен для генерирования ссылок на статические файлы (изображения, файлы таблиц стилей или файлы JS)

Так может выглядеть шаблон ``clients.html``, реализованный как наследник ``base.html``:

.. code-block:: jinja

    {% extends "base.html" %}

    {% block content %}
        <h2>{{ title }}</h2>
        {% if client_names|length == 0 %}
            <p>Клиентов не найдено.</p>
        {% else %}
            <table>
                <thead>
                    <tr>
                        <th>№</th>
                        <th>ФИО</th>
                    </tr>
                </thead>
                <tbody>
                {% for client_name in client_names %}                    
                    <tr>
                        <td>{{ loop.index }}</td>
                        <td>{{ client_name[0] }}</td>
                    </tr>
                {% endfor %}
                </tbody>
            </table>
        {% endif %}
    {% endblock %}

Управление внешним видом
========================

Язык HTML предназначен для семантической разметки документа, то есть выделения в ней смысловых блоков, и не содержит средств для задания визуального оформления элементов страницы. С этой целью веб-разработчиками используется язык CSS, позволяющий задавать наборы стилей (параметров внешнего вида) для отдельных элементов, типов элементов, классов и так далее. Помимо этого, с помощью CSS можно создавать анимации элементов и задавать параметры интерактивности, то есть реакции на действия пользователя. Гибкость языка CSS позволяет создавать веб-страницы в полном соответствии с макетом, реализованным с помощью графического редактора. Тем не менее, это требует навыков и опыта, и в рамках данного пособия работа с CSS рассматриваться не будет. Альтернативой ручного задания стилей является использование фреймворков, среди которых одним из самых популярных является Bootstrap [#bootstrap]_. Использование Bootstrap не позволит настраивать внешний вид страницы с той точностью, какой это может потребоваться с точки зрения дизайна, но оно позволяет облегчить этот процесс для приложений, требования к внешнему виду которых не является критичными.

Поскольку для рендеринга страниц в настоящем пособии используется Jinja и Flask, для удобства интеграции Bootstrap с этими инструментами удобно использовать библиотеку Bootstrap-Flask [#bootstrapflask]_. Помимо подключения Bootstrap к приложению данная библиотека содержит несколько полезных макросов [#bootstrapflaskmacros]_ (например, для рендеринга форм, сообщений, иконок, таблиц) -- функций, реализованных на языке шаблонов Jinja, некоторые из которых будут рассмотрены в дальнейшем.

Библиотека Bootstrap-Flask реализована как плагин для Flask и не может использоваться без него. В дальнейшем в настоящем пособии будет описано использование еще некоторых полезных библиотек-плагинов.

На момент создания настоящего пособия актуальными версиями являются Bootstrap 4 и Bootstrap 5. Библиотека Bootstrap-Flask поддерживает работу с обеими этими версиями. В примерах будет рассмотрена работа с Bootstrap 5.

Для использования Bootstrap-Flask необходимо установить эту библиотеку в виртуальное окружение:

.. code-block:: bash

    python -m pip install bootstrap-flask 

После этого необходимо инициализировать библиотеку в файле ``__init__.py``:

.. code-block:: python

    from flask import Flask
    from flask_bootstrap import Bootstrap5

    app = Flask(__name__)

    bootstrap = Bootstrap5(app)

    from app import routes

В шаблонах для использования стилей Bootstrap необходимо вызвать функции ``load_css`` и ``load_js``. Логично сделать это в базовом шаблоне ``base.html``, содержимое которого будет унаследовано всеми шаблонами приложения:

.. code-block:: jinja

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            {% block styles %}
                {{ bootstrap.load_css() }}
            {% endblock %}
            {% if title %}
                <title>{{ title }}</title>
            {% else %}
                <title>Добро пожаловать</title>
            {% endif %}
        </head>
        <body>
            <div><a href="{{ url_for('index') }}">Главная</a></div>
            <hr>
            {% block content %}{% endblock %}
            {% block scripts %}
                {{ bootstrap.load_js() }}
            {% endblock %}
        </body>
    </html>

Здесь вызовы функций подключения CSS и JS обернуты в блоки ``styles`` и ``scripts`` соответственно. Это удобно сделать для того, чтобы дать возможность в шаблонах-наследниках добавлять другие таблицы стилей и файлы JS в случае необходимости.

Использование данной версии шаблона будет иметь визуальные изменения по сравнению с версией без Bootstrap даже несмотря на то, что никакие стили элементам не назначались. Это происходит из-за того, что Bootstrap использует Reboot -- набор стилей, назначаемых всем элементам по умолчанию с целью визуального улучшения и унификации их внешнего вида во всех браузерах.

Данный шаблон может быть немного усовершенствован применением макроса рендеринга элемента навигации ``render_nav_item`` [#bootstrapflaskmacros]_, входящего в состав библиотеки Bootstrap-Flask. В Bootstrap предусмотрены классы, настраивающие внешний вид панели и поведение ее элементов. В HTML для создания навигационной панели используется тег ``nav``.

.. code-block:: jinja

    {% from 'bootstrap5/nav.html' import render_nav_item %}

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            {% block styles %}
                {{ bootstrap.load_css() }}
            {% endblock %}
            {% if title %}
                <title>{{ title }}</title>
            {% else %}
                <title>Добро пожаловать</title>
            {% endif %}
        </head>
        <body>
            <nav class="navbar navbar-expand-lg">
                <div class="container-fluid">
                    <div class="navbar-nav">
                        {{ render_nav_item('index', 'Главная') }}
                        {{ render_nav_item('test_connection', 'Проверить подключение') }}
                        {{ render_nav_item('get_spb_clients', 'Клиенты из СПб') }}
                    </div>
                </div>
            </nav>
            {% block content %}{% endblock %}
            {% block scripts %}
                {{ bootstrap.load_js() }}
            {% endblock %}
        </body>
    </html>

Функция ``render_nav_item`` импортируется в первой строке и принимает в качестве параметров имя представления, которое используется для создания URL ссылки, и текст, который должен быть отображен на элементе навигационной панели, и генерирует HTML-код для элемента.

Можно обратить внимание, что в примере выше элементам назначаются классы Bootstrap. Это возможно для всех элементов всех шаблонов, поскольку Bootstrap подключается в ``base.html`` с помощью ``load_css`` и ``load_js`` и доступен во всех шаблонах-наследниках. За дополнительной информацией об использовании стилей Bootstrap для настройки внешнего вида приложения можно обратиться к официальной документации [#bootstrap]_.

.. [#bootstrap] https://getbootstrap.com/
.. [#bootstrapflask] https://bootstrap-flask.readthedocs.io/
.. [#bootstrapflaskmacros] https://bootstrap-flask.readthedocs.io/en/stable/macros/

Передача параметров представлению
=================================

Чрезвычайно часто возникает необходимость создать представление, параметризованное некоторым значением или несколькими. К примеру, представление, выводящее данные о клиенте, может иметь один аргумент -- id пользователя, после чего оно может обратиться к базе данных с запросом данных о клиенте с указанным id, получить информацию о нем и передать полученные данные в шаблон для отображения. Поскольку представления являются обработчиками HTTP-запросов, необходимо, чтобы запрос содержал значения этих параметров, которые будут переданы представлению.

Возможны три способа передачи данных в запросе:

1. В параметрах URL (например, ``/client?id=123``)
2. Внутри пути в URL (например, ``/client/123/``)
3. В теле запроса

Третий способ связан с использованием форм и будет рассмотрен далее в пособии.

В целом разница между первыми двумя способами в практическом смысле не очень существенна, и выбор между ними должен сделать веб-разработчик. Первый способ является классическим, второй -- более новым и удобочитаемым, но он может слегка усложнить маршрутизацию в приложении, загромождая путь в URL. Допустимо смешение двух способов, когда некоторые данные (основные или обязательные) передаются как часть пути, а остальные - как параметры URL (например, ``/search/goods/?category=cars``).

Методы обработки двух способов передачи данных в представлении различаются.

Для данных, передаваемых в виде параметров, используется объект ``request`` и его атрибут ``args``, представляющий собой словарь переданных параметров.

.. code-block:: python

    from app import app
    from flask import request, render_template

    @app.get('/clients/')
    def get_clients():
        city = request.args.get('city')
        if city is None:                                        # если параметр не был передан
            client_names = ...                                  # получить данные о клиентах из всех городов
            return render_template('clients.html',
                                    client_names=client_names)  # и отобразить их
        client_names = ...                                      # получить данные о клиентах из города city
        return render_template('clients.html', 
                                client_names=client_names)      # и отобразить их

Представление из этого примера является усовершенствованным представлением ``get_spb_clients``, способным отображать данные о клиентах не только из Санкт-Петербурга, но и вообще из любого города в базе данных. При этом параметр ``city`` может быть идентификатором этого города, например целочисленным полем ``id`` таблицы ``City``. По GET-запросу по URL ``/clients/?city=123`` будут выводиться данные о клиентах из города с идентификатором 123, а по URL ``/clients/`` -- из всех городов.

Следует быть осторожным с доступом к элементам словаря ``args`` по ключу (например, ``request.args['city']``). В том случае, если в URL нет такого параметра, будет вызвано исключение.

Данные, передаваемые внутри пути в URL, указываются в маршруте с помощью переменных, заключенных в угловые скобки, и передаются аргументами представлению:

.. code-block:: python

    from app import app
    from flask import request, render_template

    @app.get('/clients/<city>/')
    def get_clients(city):
        client_names = ...                                  # получить данные о клиентах из города city
        return render_template('clients.html', 
                                client_names=client_names)  # и отобразить их

В этом случае проверку существования значения ``city`` производить не требуется, так это осуществляется с помощью маршрутизации Flask (представление не будет вызвано, если строка пути URL не содержит значения в месте, отмеченном угловыми скобками).

Чтобы дополнительно улучшить работу представления, было бы неплохо проверить наличие такого города в базе данных и вернуть клиенту ошибку в случае, если его нет, чтобы была понятна разница между городом, в котором нет клиентов, и городом, которого не существует. Способы сделать это рассмотрены далее в этом пособии.

Для более гибкой маршрутизации можно указать тип данных для переменной маршрута, тогда становится возможным создать разные маршруты для передаваемых значений разных типов. Для этого используется синтаксис ``<тип:имя>``. Возможны следующие типы данных:

* ``string`` (используется по умолчанию) -- строка, содержащая любые символы, кроме косой черты ``/``
* ``int`` -- целое число
* ``float`` -- вещественное число
* ``path`` -- то же, что ``string``, но с возможностью содержать символы косой черты ``/``
* ``uuid`` -- строка в формате UUID
  
К примеру, можно модифицировать представление ``get_clients`` следующим образом:

.. code-block:: python
    
    @app.get('/clients/<int:city>/')
    def get_clients(city):
        ...

Тогда оно будет вызвано для обработки запроса с URL ``/clients/123/``, но не будет вызвано для обработки запроса с URL ``/clients/spb/``.

Для URL со встроенными данными (и как часть пути, и в виде параметров) необходимо генерировать ссылки. Для этого используется упомянутая ранее функция ``url_for``. В приведенных примерах она принимала в качестве аргумента имя представления, для которого необходимо сгенерироваться ссылку. Помимо этого она может принимать произвольное количество именованных аргументов, и они сопоставляются с аргументами представления. В случае, если среди аргументов представления найден именованный аргумент функции ``url_for``, он становится частью пути в URL сформированной ссылки. Если же аргумент не найден, он становится параметром в URL.

.. code-block:: python
    
    @app.get('/index/<param1>/<param2>/')
    def main(param1, param2):
        ...

    url_for('main', param1=123, param2=456, param3=789, param4='abc')
    # сгенерированная ссылка: /index/123/456/?param3=789&param4=abc

Для создания ссылки на рассмотренное ранее представление ``get_clients`` может быть использован такой вызов:

.. code-block:: python
    
    url_for('get_clients', city=123)

В предыдущем разделе была рассмотрена работа с функцией ``render_nav_item``, которая вызывается из шаблона и позволяет генерировать HTML-код для элемента навигационной панели. Поскольку внутри элемента присутствует ссылка, функция ``render_nav_item`` вызывает для ее генерации функцию ``url_for``, при этом предусмотрен механизм передачи параметров для создания этой ссылки, которые передаются в виде произвольного количества именованных аргументов функции ``render_nav_item``:

.. code-block:: jinja

    {% from 'bootstrap5/nav.html' import render_nav_item %}
    ...
        <div class="navbar-nav">
            ...
            {% for city in cities %}
                {{ render_nav_item('get_clients', 'Клиенты из ' + city.name, city=city.id) }}
            {% endfor %}
            ...
        </div>
    ...

Следует отметить, что пользователь имеет контроль над параметрами, передаваемыми веб-приложению от клиента, и может воспользоваться этим, чтобы дестабилизировать работу приложения. По этой причине следует крайне критически относиться к любым данным, получаемым от клиента и уделять внимание проверке (валидации) любых параметров на предмет их существования, допустимости типа данных, наличия вредоносного значения (например, кода для SQL-инъекции), несоответствия уровня прав доступа пользователя (например, менеджер запрашивает данные о клиентах другого отдела, указав в запросе его id) и так далее. В особенности это правило касается данных, передаваемых с помощью форм. 

Использование форм
==================

Формы -- стандартный способ представления на HTML-странице элементов, позволяющих принять данные от пользователя и отправить их на сервер. При использовании форм возникает ряд важных, но рутинных задач, связанных с их рендерингом (отображением на веб-странице) и валидацией (проверкой корректности данных при их получении на сервере):

* Некоторые поля форм (например выпадающие списки) должны заполняться данными, получаемыми с сервера. Иногда для заполнения полей используются данные предыдущей попытки отправки формы, когда проверка данных завершилась с ошибкой, но некоторые данные были введены корректно. Не требуется заставлять пользователя вводить их повторно 
* При получении данных отправленной формы на сервере необходимо выполнить отображение ее полей на объекты приложения, чтобы сохранить полученные данные для дальнейшей обработки
* Для каждого поля необходимо проверить корректность данных, и при возникновении ошибок вернуть форму обратно для их исправления
* Для возвращенной формы необходимо подписать ошибки у тех полей, в которых они были допущены, чтобы пользователь мог их исправить
* Если есть несколько похожих форм, то их код должен копироваться, равно как и код их валидации, либо требуется изобретать какие-то способы этого избежать
  
Для упрощения решения этих и других проблем, связанных с рендерингом и валидацией форм, уместно реализовывать их как классы Python, инкапсулирующие в себе всю необходимую логику, с возможностью наследования. Такой подход используется в библиотеке WTForms [#wtforms]_, работа с которой будет рассмотрена далее. Сама библиотека WTForms не привязана к какому-либо фреймворку или шаблонизатору. Для удобства ее интеграции с Flask существует библиотека Flask-WTF [#flaskwtf]_.

Для начала работы с ними необходимо установить эти библиотеки в виртуальное окружение:

.. code-block:: bash

    python -m pip install WTForms Flask-WTF 

В целях разделения ответственности, классы форм удобно выделить в отдельный модуль, например, ``forms.py``. Так может выглядеть форма регистрации пользователя:

.. code-block:: python

    from flask_wtf import FlaskForm
    from wtforms import BooleanField, StringField, DateField, IntegerField, PasswordField, SubmitField, validators

    class RegistrationForm(FlaskForm):
        username = StringField('Имя пользователя', [validators.Length(min=4, max=25)])
        email = StringField('E-mail', [validators.Length(min=6, max=100), validators.Email()])
        password = PasswordField('Пароль', [validators.InputRequired(), 
                                            validators.Length(min=6, max=100), 
                                            validators.EqualTo('confirm', message='Пароли должны совпадать')])
        confirm  = PasswordField('Повторите пароль')
        birth_date = DateField('Дата рождения', format='%Y-%m-%d', validators=[validators.InputRequired()])
        region_code = IntegerField('Код региона', [validators.InputRequired()])
        want_spam = BooleanField('Я согласен получать рекламную рассылку', [validators.InputRequired()])
        submit = SubmitField('Зарегистрироваться')

Каждое поле формы является атрибутом класса формы и при этом экземпляром одного из классов библиотеки WTForms, отвечающих за тип поля. Каждый класс (в примере -- ``BooleanField``, ``StringField``, ``DateField``, ``IntegerField``, ``PasswordField`` и ``SubmitField``,) отвечает за то, как рендерится поле в HTML (например, экземпляры ``PasswordField`` рендерятся как элементы ``<input type="password">``, то есть вводимые символы заменяются на звездочки, экземпляры ``BooleanField`` -- как ``<input type="checkbox">`` и так далее), а также за приведение данных к какому-то типу данных при их обработке на сервере (например, экземпляры ``IntegerField`` приводят переданные данные к типу ``int``). ``SubmitField`` рендерится как кнопка отправки формы. О типах полей имеет смысл получить информацию в соответствующем разделе документации библиотеки WTForms [#wtffields]_.

Для каждого поля может задается несколько параметров в виде аргументов конструктора, часть из которых -- общие для всех типов полей. Самые важные из них -- ``label`` и ``validators``.

* ``label`` -- первый по порядку аргумент, задает текст подписи к полю. 
* ``validators`` -- второй по порядку аргумент, задает набор валидаторов -- функций, запускающихся для поля на сервере при получении данных отправленной формы и вызывающих исключение в случае, если данные не валидны, то есть не соответствуют требованиям. В примере выше для полей используются валидаторы ``InputRequired`` (поле обязательно для заполнения), ``Length`` (ограничение на длину), ``Email`` (формат ввода соответствует адресу электронной почты), ``EqualTo`` (равенство значению, введенному в другое поле формы). Некоторые валидаторы принимают параметры. Например, ``Length`` принимает параметры ``min`` и ``max`` (задают диапазон возможных размеров ввода), ``EqualTo`` -- параметр ``fieldname`` (имя поля, с чьим значением требуется произвести сравнение). Все валидаторы принимают параметр ``message`` -- сообщение об ошибке, которое должно быть сформировано в случае, если валидация завершится исключением. Если этот параметр опущен, то будет использовано встроенное в WTForms сообщение. Валидаторы, встроенные в библиотеку WTForms, весьма многочисленны, также есть возможность создания собственных. Для получения информации о доступных валидаторах и их параметрах следует обратиться к разделу документации WTForms [#wtfvalidators]_.

Как правило, использование формы в веб-приложении состоит из следующих событий:

1. Отображение формы на странице, получаемой GET-запросом. При этом объект формы создается представлением, обрабатывающим этот запрос, и передается в шаблонизатор для рендеринга.
2. Ввод пользователем данных в форму с помощью браузера и ее отправка по адресу, указанному в атрибуте формы ``action`` с помощью POST- или GET-запроса (в зависимости от значения атрибута формы ``method``).
3. Прием данных формы в представлении, обрабатывающем этот запрос, ее валидация и какие-либо дальнейшие действия в зависимости от того, валидны данные формы или нет.
   
Выбор метода HTTP для отправки данных формы лежит на плечах разработчика, но в большинстве случаев из соображений удобства и безопасности имеет смысл сделать выбор в пользу метода POST.
   
Для отображения пустой формы ее необходимо инстанцировать и передать в качестве именованного аргумента функции ``render_template``:

.. code-block:: python

    from app.forms import RegistrationForm
    from app import app
    from flask import render_template

    @app.get('/register')
    def register():
        reg_form = RegistrationForm()
        return render_template('registration.html', title='Регистрация', form=reg_form)

Шаблон ``registration.html`` может иметь такой вид:

.. code-block:: jinja

    {% extends "base.html" %}

    {% block content %}
        <h2>{{ title }}</h2>
        <form method="POST" action="/register2">
            {{ form.hidden_tag() }}
            <div>{{ form.username.label }} {{ form.username(class="form-control form-control-lg") }}</div>
            <div>{{ form.email.label }} {{ form.email(placeholder="name@example.com") }}</div>
            <div>{{ form.password.label }} {{ form.password() }}</div>
            <div>{{ form.confirm.label }} {{ form.confirm() }}</div>
            <div>{{ form.birth_date.label }} {{ form.birth_date() }}</div>
            <div>{{ form.region_code.label }} {{ form.region_code() }}</div>
            <div>{{ form.want_spam.label }} {{ form.want_spam() }}</div>
            {{ form.submit() }}
        </form>
    {% endblock %}

В данном примере необходимо обратить внимание на следующее:

* Все действия по управлению внешним видом формы остаются под контролем разработчика шаблона, WTForms отвечает только за генерацию HTML-кода отдельных полей. Это сделано намеренно с целью дать больше возможностей по настройке внешнего вида, к примеру есть возможность управлять положением подписей относительно полей (на одной строке или с переносом), а также передавать дополнительные параметры полям формы, которые рендерятся как атрибуты соответствующих элементов (в примере выше -- ``class`` для задания стиля Bootstrap, увеличивающего размер поля и ``placeholder`` для задания текста по умолчанию для подсказки пользователю необходимого формата ввода).
* В форме используется функция ``hidden_tag``. Она генерирует скрытое поле, значением которого является сгенерированный CSRF-токен. Токен рендерится вместе с формой, посылается обратно на сервер вместе с остальными данными формы и служит для того, чтобы предотвратить уязвимость CSRF (Cross-Site Request Forgery, межсайтовая подделка запросов, [#csrf]_), позволяя удостовериться, что страница, отправившая форму, является страницей, сгенерированной сервером, а не поддельной. Токен создается библиотекой Flask-WTF. Для того, чтобы этот механизм работал, необходимо, чтобы в конфигурации приложения существовал ключ ``SECRET_KEY`` (``app.config['SECRET_KEY']``).
* Форма отправляет данные POST-запросом по URL ``/register2``, представление для которого призвано обработать отправленные данные формы, но еще не создано.
  
Представление для обработки данных формы может выглядеть следующим образом:

.. code-block:: python

    from app.forms import RegistrationForm
    from app import app
    from flask import render_template

    @app.post('/register2')
    def register2():
        reg_form = RegistrationForm()
        if reg_form.valdate_on_submit():
            # создать запись в базе данных с данными reg_form.username.data, reg_form.email.data и т.д.
            return f'Регистрация пользователя {reg_form.username.data} успешна'
        return 'Ошибка при регистрации'

Здесь данные POST-запроса автоматически загружаются в форму при ее создании, а функция ``valdate_on_submit``, определенная в библиотеке Flask-WTF, проверяет, что методом запроса является POST, и запускает валидаторы для ее полей, возвращая ``True`` или ``False`` в зависимости от того, отработали ли валидаторы без вызова исключений. Следует обратить внимание, что обращение к содержимому поля формы после ее валидации возможно с помощью атрибута ``data``. Также надо иметь в виду, что обращение к атрибуту ``data`` в случае, если валидация формы закончилась неудачей, также нежелательна, поскольку может привести к ошибке. Например, в предыдущем примере пользователь мог оставить поле ``username`` пустым.

У такого подхода есть серьезная проблема: чаще всего при возникновении ошибок валидации требуется не только вывести сообщение о факте ошибки, но и отобразить форму повторно, при этом подписав ошибки у полей, которые были заполнены некорректно, и заполнив поля, с данными которых проблем не возникло. Поэтому чаще всего рендеринг исходной формы и обработку отправленных данных (а также рендеринг формы для исправления ошибок ввода) осуществляет одно и то же представление:

.. code-block:: python

    from app.forms import RegistrationForm
    from app import app
    from flask import render_template

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        reg_form = RegistrationForm()
        if reg_form.validate_on_submit():
            # создать запись в базе данных с данными reg_form.username.data, reg_form.email.data и т.д.
            return 'Регистрация {reg_form.username.data} успешна'
        return render_template('registration.html', title='Регистрация', form=reg_form)

При этом, как и ранее, объект ``reg_form`` наполняется данными запроса, если они имеются, функция ``valdate_on_submit`` проверяет метод запроса, и валидация запускается только в случае использования метода POST. Если валидация закончилась с ошибками, форма с исходными данными и с набором ошибок передается шаблонизатору и рендерится повторно.

При этом в шаблон ``registration.html`` также необходимо внести изменения:

.. code-block:: jinja

    {% extends "base.html" %}

    {% block content %}
        <h2>{{ title }}</h2>
        <form method="POST" action="">
            {{ form.hidden_tag() }}
            {% if form.username.errors %}
                {% for error in form.username.errors %}
                    <div class="invalid-feedback">{{ error }}</div>
                {% endfor %}
            {% endif %}
            <div>{{ form.username.label }} {{ form.username(class="form-control form-control-lg") }}</div>
            {% if form.email.errors %}
                {% for error in form.email.errors %}
                    <div class="invalid-feedback">{{ error }}</div>
                {% endfor %}
            {% endif %}
            <div>{{ form.email.label }} {{ form.email(placeholder="name@example.com") }}</div>
            <!-- ... -->
            <!-- остальные поля формы с проверкой ошибок -->
            <!-- ... -->
        </form>
    {% endblock %}

* Атрибут ``action`` формы теперь должен вести на тот же URL, на который поступил изначальный запрос для отображения формы. Для этого можно оставить его пустым.
* Для каждого поля формы может присутствовать набор ошибок, которые необходимо отобразить рядом с этим полем. Для этого можно использовать итерирование по списку ошибок.  

Для облегчения создания форм в упоминавшейся ранее библиотеке Bootstrap-Flask существуют макросы ``render_field`` и ``render_form`` [#bootstrapflaskmacros]_.

Макрос ``render_field`` позволяет рендерить отдельное поле в соответствии с его типом и отображать все ошибки, которые поступили после его валидации:

.. code-block:: jinja

    {% extends "base.html" %}
    {% from 'bootstrap5/form.html' import render_field %}

    {% block content %}
        <h2>{{ title }}</h2>
        <form method="POST" action="">
            {{ form.hidden_tag() }}
            {{ render_field(form.username, class="form-control form-control-lg") }}
            {{ render_field(form.email, placeholder="name@example.com") }}
            <!-- ... -->
            <!-- остальные поля формы -->
            <!-- ... -->
        </form>
    {% endblock %}

Макрос ``render_form`` рендерит всю форму целиком:

.. code-block:: jinja

    {% extends "base.html" %}
    {% from 'bootstrap5/form.html' import render_form %}

    {% block content %}
        <h2>{{ title }}</h2>
        {{ render_form(form, method="POST", action="") }}
    {% endblock %}

Данные макросы в разной степени ускоряют разработку шаблонов, использующих формы, и в разной степени уменьшают степень контроля разработчика шаблона над тем, как будет выглядеть форма. Тем не менее, генерируемый данными макросами код для форм и их полей чаще всего является вполне адекватным и приемлемым, и при отсутствии специфических требований к внешнему виду форм, реализовать которые с использованием макросов невозможно, их применение оправданно.

Часто при создании форм необходимо наполнить их данными не из POST-запроса (как в случае повторного отображения неверно отправленной формы), а из базы данных. Например, такое может потребоваться для создания поля формы, представляющего собой выпадающий список (элементы списка должны быть взяты из базы данных) или для редактирования некоторого существующего объекта (например, пользователя). В этом случае при конструировании формы можно передавать в качестве именованных аргументов значения, которые будут заполнены в поля формы при ее отображении.

К примеру, форма редактирования существующего пользователя может выглядеть так:

.. code-block:: python

    from flask_wtf import FlaskForm
    from wtforms import BooleanField, StringField, DateField, IntegerField, SelectField, SubmitField, validators

    class EditUserForm(FlaskForm):
        email = StringField('E-mail', [validators.Length(min=6, max=100), validators.Email()])
        birth_date = DateField('Дата рождения', format='%Y-%m-%d', validators=[validators.InputRequired()])
        region_code = IntegerField('Код региона', [validators.InputRequired()])
        want_spam = BooleanField('Я согласен получать рекламную рассылку', [validators.InputRequired()])
        city = SelectField('Город', coerce=int)
        submit = SubmitField('Сохранить')

В данном примере поле класса ``SelectField`` представляет собой выпадающий список (рендерится как элемент ``select``). Аргумент ``coerce`` определяет, к какому типу приводится значение, введенное в данное поле. Для этого примера типом значения является ``int``, что означает, что атрибуты ``value`` элементов ``option`` выпадающего списка будут строками с целыми числами, и будут приведены к целым числам на сервере. То есть HTML-код поля может быть примерно таким:

.. code-block:: html

    <select name="city">
        <option value="123">Санкт-Петербург</option>
        <option value="456">Москва</option>
        <option value="789">Калининград</option>
    </select>

Соответствующее представление может передавать конструктору формы данные существующего пользователя:

.. code-block:: python

    from app import app
    from app.forms import EditUserForm
    from flask import render_template, redirect, flash, url_for

    @app.route('/edituser/<int:user_id>', methods=['GET', 'POST'])
    def edit_user(user_id):
        # здесь должна быть проверка, имеет ли текущий пользователь право на редактирование пользователя user_id,
        # например это тот же самый пользователь, либо текущий пользователь является администратором,
        # и что пользователь user_id вообще существует
        with psycopg.connect(...) as con:
            cur = con.cursor()
            email, bd, rc, ws, ci = cur.execute('SELECT email, bd, rc, ws, city_id '
                                                'FROM "user" '
                                                'WHERE id = %s', (user_id,)).fetchone()
            cities = cur.execute('SELECT id, name '
                                 'FROM city '
                                 'ORDER BY name DESC').fetchall()
        form = EditUserForm(email=email, birth_date=bd, region_code=rc, want_spam=ws, city=ci)
        form.city.choices = cities
        if form.valdate_on_submit():
            # сохранить новые данные пользователя в базе данных
            flash('Изменения сохранены')
            return redirect(url_for('edit_user', user_id=user_id))
        return render_template('edit_user.html', title='Редактирование пользователя', form=form)

Классы форм спроектированы таким образом, что данные для их заполнения берутся из POST-запроса, а отсутствующие в POST-запросе -- наполняются значениями из аргументов конструктора. По этой причине данное представление будет корректно обрабатывать и GET-запросы (то есть просто заход на страницу редактирования пользователя, в этом случае данные будут получены из базы данных), и POST-запросы (то есть получение данных формы редактирования пользователя, в этом случае форма повторно наполняется этими данными).

Атрибут ``choices`` поля ``SelectField`` означает элементы выпадающего списка и принимает значение списка кортежей из двух элементов, где первый -- атрибут ``value`` элемента списка (значение, которое будет передано при отправке формы), а второй -- текст элемента списка. В примере значением атрибута ``choices`` выступает список ``cities``, представляющий собой id и имена всех городов, полученные из базы данных. Аргумент конструктора формы ``city=ci`` в случае ``SelectField`` устанавливает значение, выбранное в списке по умолчанию.

Функции ``flash`` и ``redirect`` осуществляют соответственно вывод информационного сообщения и перенаправление, и будут рассмотрены позже в этом пособии.

.. [#wtforms] https://wtforms.readthedocs.io/
.. [#flaskwtf] https://flask-wtf.readthedocs.io/
.. [#wtffields] https://wtforms.readthedocs.io/en/3.1.x/fields/
.. [#wtfvalidators] https://wtforms.readthedocs.io/en/3.1.x/validators/
.. [#csrf] https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0

Формирование ответов
====================

В примерах в данном пособии возвращаемым значением представления являлась либо явно указываемая строка, либо строка, возвращаемая функцией ``render_template`` (шаблон, обработанный движком Jinja). В действительности перед тем послать клиенту ответ, Flask создает объект класса ``Response``, формируя из возвращаемой строки тело ответа и добавляя необходимый код состояния (по умолчанию ``200 OK``) и заголовки (в частности, ``Content-Type: text/html``). Иногда требуется изменить это поведение, к примеру, чтобы представление вернуло код состояния некоторой ошибки или перенаправления, либо переопределить какие-то заголовки или добавить свои. Рассмотрим типичный пример, когда этом может понадобиться.

В случае, если в приложении возникает какое-то необработанное исключение (например, запрос в базу данных вернул 0 строк, а мы пытаемся обратиться к данным из этой выборки), то Flask генерирует ответ с кодом состояния ``500 Internal Server Error``. При этом в реальности такая ошибка может возникать по вине пользователя (например, он допустил опечатку в имени клиента), но возвращаемая информация (сведения о том, что на сервере произошла неизвестная ошибка) не позволяет пользователю понять это и исправить ее. Гораздо практичнее было бы вернуть ответ с кодом состояния ``404 Not Found``, свидетельствующую о том, что клиент не найден.

Для того чтобы этого добиться, можно воспользоваться способностью представления вернуть не строку, а кортеж.

Кортеж, возвращаемый представлением, может иметь следующую структуру:

* (тело, код состояния)
* (тело, заголовки)
* (тело, код состояния, заголовки)
  
Код состояния в примерах выше является числом (200, 301, 403, ...), а заголовки -- словарем. Надо отметить, что в качестве тела ответа может выступать не только строка, но и список или словарь, в этом случае Flask сформирует ответ в формате JSON и настроит заголовок ``Content-Type: application/json``. В данном пособии такие примеры не рассмотрены.

Например, есть возможность вернуть ответ с кодом состояния ``404 Not Found`` в случае, если какие-то данные не были найдены в базе данных:

.. code-block:: python

    from app import app

    @app.get('/client/<string:client_name>/')
    def get_client(client_name):
        # поиск клиента в базе данных
        if client is None:
            return 'Клиент не найден!', 404
        # отображение информации о клиенте
  
Такой подход не всегда практичен, поскольку в приложении может возникать много различных ошибок, соответствующих коду состояния ``404 Not Found`` (не найдены могут быть клиенты, заказы, товары и так далее), а также ошибки, соответствующие другим кодам состояний (например, ``401 Access Denied``), и предусмотреть все случаи может быть сложно. При этом создавать шаблоны для каждой ошибки может быть трудоемко. Flask генерирует ответы с ошибками 404 (и другими кодами, если это необходимо) автоматически, например, если при разборе URL запроса не найдено представление, которое соответствует переданному пути. Чтобы унифицировать поведение системы в случае, если необходима генерация той или иной ошибки, можно воспользоваться функцией ``abort``, которая принимает в качестве аргумента необходимый код состояния и вызывает исключение, обрабатываемое веб-сервером, который умеет генерировать коды ошибок для всех известных ему кодов состояний HTTP:

.. code-block:: python

    from app import app

    @app.get('/client/<string:client_name>/')
    def get_client(client_name):
        # поиск клиента в базе данных
        if client is None:
            abort(404)
        # отображение информации о клиенте

Поскольку ``abort`` вызывает исключение, выполнение текущего представления будет прервано, как и в случае с оператором ``return`` в предыдущем примере.

Если необходимо изменить внешний вид страницы с сообщением об ошибке, можно воспользоваться функцией, снабженной декоратором ``errorhandler``:

.. code-block:: python

    from flask import render_template
    from app import app

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('not_found.html'), 404

В этом случае шаблон ``not_found.html`` будет рендериться для всех ошибок ``404 Not Found`` приложения. Аналогичным образом можно определить шаблоны для обработки других ошибок, например ``401 Access Denied`` или ``500 Internal Server Error``.

Другим часто требуемым изменением ответа по умолчанию является необходимость вернуть код состояния HTTP ``302 Found``, ``301 Moved Permanently`` или какой-то другой код класса 3хх, соответствующий перенаправлению (редиректу). В этом случае браузер делает повторный запрос по URL, указанному в заголовке ответа ``Location``, и пользователь "переходит" на страницу, куда его перенаправил сервер.

Для облегчения формирования ответов, содержащих перенаправления, служит функция ``redirect``:

.. code-block:: python

    from app import app
    from flask import redirect, url_for
    from flask_login import current_user

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if current_user.is_authenticated:
            # нет необходимости аутентифицировать пользователя повторно,
            # вместо этого можно перенаправить его на главную страницу
            return redirect(url_for('index'))
        # процедура аутентификации

Вывод информационных сообщений
==============================

Полезно иметь механизм отправки сообщений пользователю об успешных или неудачных действиях, которые он совершает в приложении. В особенности это касается перенаправлений, когда пользователь получает другую страницу приложения и не может быть уверен в том, чем закончилось его предыдущее действие. Использование механизма информационных сообщений не обязательно, но может значительно улучшить пользовательский опыт.

Вернемся к примеру использования формы редактирования пользователя.

.. code-block:: python

    from app import app
    from app.forms import EditUserForm
    from flask import render_template, redirect, flash, url_for

    @app.route('/edituser/<int:user_id>', methods=['GET', 'POST'])
    def edit_user(user_id):
        # ...
        form = EditUserForm(...)
        # ...
        if form.valdate_on_submit():
            # сохранить новые данные пользователя в базе данных
            flash('Изменения сохранены', 'success')
            return redirect(url_for('edit_user', user_id=user_id))
        return render_template('edit_user.html', title='Редактирование пользователя', form=form)

В этом примере перед завершением представления с формированием ответа с кодом состояния перенаправления вызывается функция ``flash``. Она позволяет поместить информационное сообщение в специальное временное хранилище, которое доступно между запросами и позволяет выводить сообщений однократно при запросе следующей страницы. В примере выше сообщение будет выведено на странице редактирования пользователя, на которую сработает перенаправление после успешной записи данных в базу данных.

Функция ``flash`` имеет один обязательный аргумент -- сообщение, которое необходимо вывести на следующей загруженной странице. Также можно указать второй аргумент -- категорию сообщения. Категории могут быть произвольными и влияют на внешний вид сообщения (например, его цвет), если настроены соответствующие стили.

Для отображения сообщений в шаблоне можно воспользоваться функцией ``get_flashed_messages``. Сделать это целесообразно в шаблоне ``base.html``, поскольку сообщения могут понадобиться на любой странице, сгенерированной с помощью шаблона-наследника.

.. code-block:: jinja

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <!-- ... -->
        </head>
        <body>
            <!-- ... -->
            {% with messages = get_flashed_messages() %}
                {% if messages %}
                    <ul>
                    {% for message in messages %}
                        <li>{{ message }}</li>
                    {% endfor %}
                    </ul>
                {% endif %}
            {% endwith %}
            {% block content %}{% endblock %}
            <!-- ... -->
        </body>
    </html>

В примере блок сообщений представлен списком, который выводится над основным контентом страницы (блоком ``content``).

В случае, если для сообщений задаются категории, код шаблона будет выглядеть несколько иначе:

.. code-block:: jinja

    <!-- ... -->
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <ul>
            {% for category, message in messages %}
                <li class="{{ category }}">{{ message }}</li>
            {% endfor %}
            </ul>
        {% endif %}
    {% endwith %}
    <!-- ... -->

В данном случае функция ``get_flashed_messages`` вызывается с дополнительным аргументом ``with_categories`` и возвращает список кортежей из категории сообщения и его текста. Категория может применяться, например, что задания класса для элемента списка, что может влиять на его внешний вид.

Библиотека Bootstrap-Flask, рассмотренная ранее, содержит макрос ``render_messages`` для удобного отображения сообщений с применением стилей Bootstrap.

.. code-block:: jinja

    {% from 'bootstrap5/utils.html' import render_messages %}

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <!-- ... -->
        </head>
        <body>
            <!-- ... -->
            {{ render_messages() }}
            {% block content %}{% endblock %}
            <!-- ... -->
        </body>
    </html>

В этом случае если для сообщений применяются категории, то это должны быть категории, соответствующие типам сообщений Bootstrap: ``primary``, ``secondary``, ``success``, ``danger``, ``warning``, ``info``, ``light`` или ``dark``. Тогда они будут визуализированы в соответствующей цветовой палитре.

Использование макроса ``render_messages``, как и макросов, рассмотренных ранее в данном пособии, существенно облегчает создание шаблонов, но снижает контроль разработчика над тем, как выглядят сообщения.

Отдача статических файлов
=========================

Статические файлы в понимании веб-приложений -- те, которые не генерируются программным кодом на сервере при запросе. К таким файлам чаще всего относятся изображения, файлы таблиц стилей CSS, файлы с кодом на JavaScript, шрифты. Как правило такие файлы должны обрабатываться серверами особо, поскольку при обращении к ним не требуется запуск программного кода, также они могут кэшироваться в браузере клиента, чтобы не скачиваться с каждым запросом клиента, что уменьшает нагрузку на сервер.

В Flask есть встроенные механизмы для отдачи статического содержимого. Для их использования достаточно создать каталог ``static`` внутри каталога приложения. Внутри него можно сохранять файлы (например, изображения), которые необходимо отдавать статически. Например, если создать в каталоге ``static`` файл ``logo.png``, то он будет доступен по URL ``/static/logo.png``. Также есть возможность создать в каталоге ``static`` подкаталоги для разных типов файлов, например, ``static/img``, ``static/css``, ``static/js``.

Структура каталогов приложения при этом может выглядеть следующим образом:

::

    myproject/
    ├─ app/
    │  ├─ static/
    │  |  ├─ img/
    │  │  |  ├─ logo.png
    │  │  |  ├─ ...
    │  |  ├─ ...
    |  ├─ templates/
    │  |  ├─ base.html
    │  |  ├─ ...
    │  ├─ __init__.py
    |  ├─ config.py
    │  ├─ forms.py
    │  ├─ routes.py
    │  ├─ user.py
    ├─ venv/
    │  ├─ ...
    ├─ .env
    ├─ .gitignore
    ├─ myproject.py
    ├─ requirements.txt
    ├─ start.sh

Функция ``url_for`` настроена для генерирования URL статических файлов следующим образом:

.. code-block:: jinja

    <img src="{{ url_for('static', filename='img/logo.png') }}" />

==========================================
Аутентификация и авторизация пользователей
==========================================

Общие сведения
==============

Аутентификация и авторизация -- важнейшие задачи, которые позволяет разделять функционал приложения на функциональные части, доступные неаутентифицированным пользователям и доступные только после аутентификации, а также назначать пользователям различные роли с различными правами. Если приложение работает с чувствительными данными, использование аутентификации позволяет удостовериться, что пользователь в действительности является тем, за кого себя выдает, и на самом деле имеет право на доступ к тем или иным данным или операциям. Также приложение может предоставлять некоторый персонализированный опыт, к примеру, личный кабинет, история, индивидуальные настройки.

Следует различать понятия аутентификации и авторизации.

Аутентификация -- проверка личности пользователя (например, путем сопоставления логина и пароля) с целью подтверждения того, что он имеет право на вход в систему.

Авторизация -- определение того, какие ресурсы или функциональные части системы доступны пользователю, прошедшему аутентификацию, с учетом его роли.

Обеспечение надлежащей аутентификации и авторизации в веб-приложениях -- трудоемкая задача, которая включает в себя:

1. Обеспечение источника информации об учетных записях пользователей (например, таблица ``user`` в базе данных)
2. Реализацию функционала регистрации пользователей (создание учетных записей)
3. Хранение информации о текущем пользователе в сеансе веб-приложения
4. Загрузка информации о пользователе на основании информации, хранящейся в сеансе
5. Обеспечение функционала входа в систему (записи информации о пользователе в сеанс) и выхода из системы (удаления этой информации)
6. Обеспечение функционала "Запомнить меня"
7. Разграничение прав неаутентифицированный пользователь -- аутентифицированный пользователь
8. Авторизация аутентифицированного пользователя на выполнение тех или иных действий на основании его прав.

В данном списке п. 3 реализуется фреймворком Flask. Также в этом разделе будет рассмотрен плагин Flask-Login, реализующий пп. 5, 6 и 7. Пп. 1, 2 и 8 необходимо реализовать самостоятельно.

Хранение учетных записей и регистрация пользователей
====================================================

Хранение учетных записей допустимо осуществлять в базе данных приложения. При этом аутентификационные данные не обязательно должны храниться в базе данных (к примеру, может использоваться технология единого входа, например, OpenID [#openid]_). В данном пособии для простоты остановимся на механизме аутентификации, включающем хранение аутентификационных данных в базе данных приложения.

.. [#openid] https://ru.wikipedia.org/wiki/OpenID

На этапе проектирования базы данных необходимо принять решение о том, какие роли пользователей будут в веб-приложении, будут ли у разных ролей пользователей специфичные для них атрибуты и будет ли список ролей расширяться в дальнейшем.

В простейшем случае можно ограничиться одной таблицей, содержащей информацию обо всех пользователях.

.. code-block:: sql
   
    CREATE TABLE "user" (
    "id"            INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "username"      VARCHAR(50) UNIQUE NOT NULL,
    "password"      VARCHAR(255) NOT NULL,
    "first_name"    VARCHAR(100) NOT NULL,
    "last_name"     VARCHAR(100) NOT NULL,
    "role_id"       INT NOT NULL REFERENCES "role" ("id"),
    "date_of_birth" DATE
    );

Здесь предполагается, что у пользователей разных ролей нет никаких дополнительных атрибутов, кроме, собственно, этой роли. Таблица ``role`` может быть тривиальной:

.. code-block:: sql
   
    CREATE TABLE "role" (
    "id"    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "name"  VARCHAR(30) UNIQUE NOT NULL,
    );

Такое решение является довольно ограниченным, поскольку чаще всего различные пользователи (сотрудники, клиенты, администраторы и т.д.) обладают существенным различием не только в функционале, но и в хранящихся о них данных (у сотрудников есть отделы и принятые заказы, у клиентов -- адреса и оформленные заказы и т.д.). Также это может создать проблемы, если в будущем появится роль, пользователи которой имеют специфические свойства. 

Альтернативным вариантом хранения данных о пользователях являются отдельные таблицы для каждой роли. При этом таблицы хранят ссылки на центральную таблицу с аутентификационными данными и содержат специфичные для роли атрибуты. Между такими таблицами устанавливаются связи "один-к-одному".

.. code-block:: sql
   
    CREATE TABLE "user" (
    "id"            INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "username"      VARCHAR(50) UNIQUE NOT NULL,
    "password"      VARCHAR(255) NOT NULL,
    "role"          INTEGER NOT NULL,  -- 1: admin, 2: client, 3: customer
    -- общие атрибуты для всех ролей
    );

    CREATE TABLE "admin" (
    "id"        INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "user_id"   INTEGER UNIQUE NOT NULL REFERENCES "user" ("id"),
    -- специфичные атрибуты для администраторов
    );

    CREATE TABLE "client" (
    "id"        INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "user_id"   INTEGER UNIQUE NOT NULL REFERENCES "user" ("id"),
    -- специфичные атрибуты для клиентов
    );

    CREATE TABLE "employee" (
    "id"        INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
    "user_id"   INTEGER UNIQUE NOT NULL REFERENCES "user" ("id"),
    -- специфичные атрибуты для сотрудников
    );

Важным аспектом является хранение паролей. В современной практике разработки систем, использующих механизмы аутентификации, считается чрезвычайно плохим тоном хранение паролей в базе данных в открытом виде. Помимо очевидных угроз и виде возможности хакерских атак с целью кражи данных, которые могут привести к компрометации паролей и ущербу пользователям, доступ даже доверенных администраторов к таблице с подобными данными представляет существенную опасность ввиду человеческого фактора. По этой причине пароли нужно как минимум хешировать криптостойкими алгоритмами, желательно используя соль [#salt]_.

.. [#salt] https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)

В Werkzeug (компонент Flask) встроены функции для удобной генерации хеша пароля с солью (``generate_password_hash``) и проверки пароля на соответствие хешу (``check_password_hash``). При этом используется встроенный в стандартную библиотеку Python криптографический алгоритм scrypt [#scrypt]_.

.. [#scrypt] https://ru.wikipedia.org/wiki/Scrypt

Типичное использование функции ``generate_password_hash`` проиллюстрировано в следующем представлении регистрации:

.. code-block:: python

    from werkzeug.security import generate_password_hash
    from app import app
    from flask import redirect, render_template, flash
    from app.forms import RegistrationForm

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        reg_form = RegistrationForm()
        if reg_form.validate_on_submit():
            password_hash = generate_password_hash(reg_form.password.data)
            # создать запись в таблице user используя password_hash
            # создать запись в таблице, соответствующей роли пользователя
            flash(f'Регистрация {reg_form.username.data} успешна', 'success')
            return redirect(url_for('login'))
        return render_template('registration.html', title='Регистрация', form=reg_form)

Объект ``current_user`` представляет собой информацию о текущем пользователе в контексте запроса, а его атрибут ``is_authenticated`` возвращает ``True`` если пользователь уже аутентифицирован (т.е. вошел в систему). Проверка, выполняемая в представлении регистрации, нужна для того, чтобы аутентифицированный в системе пользователь не мог по ошибке воспользоваться формой регистрации. Особенности работы с объектом ``current_user`` будут рассмотрены далее в этом разделе.

Аутентификация пользователей
============================

Следующей задачей является реализация процедуры аутентификации (входа в систему) и механизма хранения аутентификационных данных в сеансе приложения. Прежде чем начать разговор на эту тему, полезно убедиться, что есть понимание того, как устроены сеансы работы пользователя в веб-приложениях.

Протокол HTTP характеризуется отсутствием "состояния", т.е хранения какой-либо информации о запросах клиента, и любой запрос от клиента к серверу является независимым и не содержит информации об их предыдущем взаимодействии. Так, например, невозможен запрос в духе "верни следующую запись", поскольку термин "следующий" предполагает, что сервер "помнит" какая запись была возвращена в предыдущем запросе. Но как только обработка запроса заканчивается, связь между клиентом и сервером обрывается, и сервер "забывает" о факте взаимодействия. Это создает проблему как только речь заходит о некоторой персональной информации, относящейся к клиенту, которую необходимо сохранять между запросами, например, настройки темы оформления сайта, содержимое корзины и тому подобное. И самое очевидное, между запросами необходимо хранить статус аутентификации, иными словами запоминать факт того, что пользователь уже вводил логин и пароль, и не требовать делать это при каждом запросе.

Частично эта проблема решается применением механизма cookies в браузерах [#cookies]_. С использованием cookies на стороне клиента может храниться вся необходимая для взаимодействия информация, и содержимое cookie может посылаться в теле каждого запроса клиента к серверу (в заголовке запроса ``Cookie``). К сожалению, такой подход порождает множество уязвимостей, таких как кража или подмена cookie, поскольку данные в cookie могут быть легко скомпрометированы.

Для поддержки сохранения аутентификационных и некоторых других данных между запросами клиента в современных приложениях часто используется механизм сеанса (или сессии) [#session]_. В этом случае при первом запросе клиента к серверу генерируется уникальный идентификатор сессии, который сохраняется на стороне сервера во временном хранилище и с которым связываются все необходимые данные, относящиеся к текущему сеансу клиента (прежде всего -- его аутентификация). Для клиента возникает необходимость сохранять в cookie только этот идентификатор, который предъявляется серверу с каждым запросом, что позволяет восстановить контекст предыдущего взаимодействия на стороне сервера.

.. [#cookies] https://ru.wikipedia.org/wiki/Cookie
.. [#session] https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%81%D1%81%D0%B8%D1%8F_(%D0%B2%D0%B5%D0%B1-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0)

Перед разработчиком встает задача обеспечить логику создания сессии, сохранения ее данных на сервере, загрузки данных о пользователе и контексте его работы при предъявлении клиентом идентификатора сессии в HTTP-запросе, а также входа в систему и выхода из системы. Также важным является позаботиться о защите от подделки cookie, содержащих идентификатор сессии пользователя. Для облегчения этих задачи рассмотрим использование популярной библиотеки Flask-Login [#flasklogin]_. Она является плагином Flask и не может быть использована без этого фреймворка.

Для начала необходимо установить библиотеку, выполнив в виртуальном окружении команду

.. code-block:: bash

    python -m pip install flask-login

После этого следует произвести инициализацию механизмов библиотеки, путем включения в файл ``__init__.py`` следующего кода:

.. code-block:: python

    from flask import Flask
    from flask_bootstrap import Bootstrap5
    from flask_login import LoginManager

    app = Flask(__name__)

    bootstrap = Bootstrap5(app)
    login_manager = LoginManager()
    login_manager.init_app(app)

    from app import routes

Flask-Login опирается на механизм сессий, встроенный в Flask (глобальный объект ``session``, представляющий собой словарь, сохраняющий данные, относящиеся к конкретному пользователю между его запросами), а тот в свою очередь не может работать без установки в конфигурации приложения секретного ключа (``app.config['SECRET_KEY']``), которым подписываются данные, посылаемые для сохранения в cookie. Это тот же самый ключ, который используется библиотекой Flask-WTF для генерирования токенов, защищающих формы от CSRF-атак.

Для работы плагин Flask-Login требует реализации класса, который в приложении представляет пользователя, а также функции, которая загружает данные о пользователе из базы данных по его идентификатору, хранящемуся в сессии.

Класс пользователя для использовании в Flask-Login должен предоставлять некоторый интерфейс, с которым библиотека будет взаимодействовать. Чтобы упростить создание такого интерфейса, библиотека предоставляет класс ``UserMixin``, от которого можно унаследовать необходимый интерфейс, при желании изменяя его реализацию.

Так может выглядеть простейшая реализация класса пользователя для приложения, использующего Flask-Login. В целях организации кода можно поместить его в модуль ``user.py``. В этом же файле уместно определить функцию загрузки информации о пользователе по его идентификатору.

.. code-block:: python

    import psycopg
    from app import login_manager
    from flask_login import UserMixin

    class User(UserMixin):
        def __init__(self, id, username, password):
            self.id = id
            self.username = username
            self.password = password

    @login_manager.user_loader
    def load_user(id):
        with psycopg.connect(...) as con:
            cur = con.cursor()
            username, password = cur.execute('SELECT username, password '
                                             'FROM "user" '
                                             'WHERE id = %s', (id,)).fetchone()
        return User(id, username, password)

Следует обратить внимание, что функция ``load_user`` регистрируется в библиотеке Flask-Login как функция загрузки пользователя с помощью декоратора ``login_manager.user_loader``, принимает строку с id пользователя и возвращает объект пользователя.

Теперь, когда Flask-Login настроен для работы, можно реализовать с его помощью функционал входа в систему и выхода из системы.

Форма логина довольно несложная и может быть создана в ``forms.py`` следующим образом:

.. code-block:: python

    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, BooleanField, SubmitField, validators

    class LoginForm(FlaskForm):
        username = StringField('Логин', [validators.InputRequired()])
        password = PasswordField('Пароль', [validators.InputRequired()])
        remember_me = BooleanField('Запомнить меня')
        submit = SubmitField('Войти')

Более интересна логика представления для входа в систему.

.. code-block:: python

    from werkzeug.security import check_password_hash
    from app import app
    from app.forms import LoginForm
    from app.user import User
    from flask import render_template, redirect, flash, url_for
    from flask_login import login_user, current_user

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        login_form = LoginForm()
        if form.validate_on_submit():
            with psycopg.connect(...) as con:
                res = cur.execute('SELECT id, username, password ' 
                                  'FROM "user" '
                                  'WHERE username = %s', (login_form.username.data,)).fetchone()
            if res is None or not check_password_hash(res[2], login_form.password.data):
                flash('Попытка входа неудачна', 'danger')
                return redirect(url_for('login'))
            id, username, password = res
            user = User(id, username, password)
            login_user(user, remember=login_form.remember_me.data)
            flash(f'Вы успешно вошли в систему, {current_user.username}', 'danger')
            return redirect(url_for('index'))
        return render_template('login.html', title='Вход', form=login_form)

Следует обратить внимание на следующие моменты:

* Перед проверкой пароля необходимо убедиться в существовании пользователя с таким логином (в примере выше -- ``res is None``)
* Функция ``check_password_hash`` принимает два аргумента: хеш пароля из базы данных и пароль, введенный в форму, и проверяет, соответствует ли пароль хешу
* Непосредственно вход в систему (создание сессии и запись в нее аутентификационных данных) осуществляет функция ``login_user`` библиотеки Flask-Login. Она принимает объект пользователя и булев атрибут ``remember`` -- надо ли запоминать аутентификационные данные при закрытии окна браузера клиента
  
Авторизация пользователя
========================
  
Данные текущего аутентифицированного пользователя после выполнения входа в систему доступны в сеансе пользователя в виде глобального объекта ``current_user``. Этот объект доступен в представлениях и в шаблонах.

С помощью объекта ``current_user`` и его поля ``is_authenticated`` можно проверять статус аутентификации текущего пользователя (вошел он в систему или нет):

.. code-block:: python
    
    from flask import render_template
    from flask_login import current_user
    from app import app

    @app.route('/')
    def index():
        if current_user.is_authenticated:
            return render_template('authenticated_home.html')
        else:
            return render_template('public_home.html')

В данном примере пользователю возвращаются разные шаблоны в зависимости от аутентифицированности. Внутри же шаблона данный объект может использоваться для предоставления различного содержимого:

.. code-block:: jinja

    {% if current_user.is_authenticated %}
        <p>Добро пожаловать, {{ current_user.username }}!</p>
        <a href="{{ url_for('logout') }}">Выйти</a>
    {% else %}
        <p>Вы не вошли в систему.</p>
        <a href="{{ url_for('login') }}">Войти</a>
    {% endif %}

Flask-Login позволяет полностью запрещать доступ неаутентифицированным пользователям к тем или иным представлениям. При попытке сделать запрос по соответствующему URL не вошедший в систему пользователь будет получать ответ с кодом состояния ``401 Unauthorized``. Для этого используется декоратор ``login_required``:

.. code-block:: python
    
    from flask_login import login_required
    from app import app

    @app.route('/profile')
    @login_required
    def profile():
        # ...
  
Представление выхода из системы тривиально:

.. code-block:: python

    from app import app
    from flask_login import logout_user
    from flask import redirect, url_for

    @app.route('/logout')
    def logout():
        logout_user()
        return redirect(url_for('index'))

Здесь с помощью функции ``logout_user`` библиотеки Flask-Login происходит удаление сессии текущего пользователя. Объект ``current_user`` после этого остается доступен, но его атрибут ``is_authenticated`` будет возвращать ``False``.

Роли пользователей
==================

К сожалению, Flask-Login не предоставляет функциональности для разделения пользователей по ролям, наделенных разными правами. Это довольно несложно реализуется вручную модификацией класса пользователя. Например, если в таблице ``user`` существует целочисленная колонка ``role``, можно добавить соответствующий атрибут в класс ``User``:

.. code-block:: python

    import psycopg
    from app import login_manager
    from flask_login import UserMixin

    class User(UserMixin):
        def __init__(self, id, username, password, role):
            self.id = id
            self.username = username
            self.password = password
            self.role = role

    @login_manager.user_loader
    def load_user(id):
        with psycopg.connect(...) as con:
            cur = con.cursor()
            username, password, role = cur.execute('SELECT username, password, role '
                                                   'FROM "user" '
                                                   'WHERE id = %s', (id,)).fetchone()
        return User(id, username, password, role)

После этого после выполнения аутентификации пользователем разработчик сможет получать информацию о его роли с помощью атрибута ``role`` объекта ``current_user``:

.. code-block:: python

    from flask import render_template, abort
    from flask_login import current_user, login_required
    from app.forms import AdminForm
    from app import app
    
    @app.route('/admin', methods=['GET', 'POST'])
    @login_required
    def admin():
        if current_user.role != 1:
            abort(403)
        form = AdminForm()
        # Обработка формы и выполнение действий для администратора
        return render_template('admin.html', title='Панель администратора', form=form)

В шаблонах можно отображать то или иное содержимое только для некоторых ролей:

.. code-block:: jinja

    {% if current_user.is_authenticated %}
        <p>Добро пожаловать, {{ current_user.username }}!</p>
        {% if current_user.role == 1 %}
            <!-- пользователь является администратором -->
            <a href="{{ url_for('admin') }}">Панель администратора</a>
        {% elif current_user.role == 2 %}
            <!-- пользователь является клиентом -->
            <a href="{{ url_for('orders') }}">Ваши заказы</a>
        {% endif %}
        <a href="{{ url_for('logout') }}">Выйти</a>
    {% else %}
        <p>Вы не вошли в систему.</p>
        <a href="{{ url_for('login') }}">Войти</a>
    {% endif %}

.. [#flasklogin] https://flask-login.readthedocs.io/

=====================================
Облачное развертывание веб-приложения
=====================================

Процесс ввода в эксплуатацию, или развертывания (иногда также "деплой", от английского "deploy"), веб-приложений, даже небольших, имеет множество тонкостей, которые необходимо принять во внимание. Само развертывание может происходить с помощью различных моделей облачных сервисов, от этого может зависеть сложность процесса развертывания и поддержки, стоимость эксплуатации системы и ее надежность.

В этом разделе не будут рассмотрены способы развертывания, которые можно зонтично охарактеризовать как self-hosted, то есть осуществляемые на собственном оборудовании. Такой подход требует значительных усилий по настройке оборудования и операционной системы, а также ручной организации мониторинга, резервного копирования и восстановления, информационной безопасности. В противоположность этому облачные решения предоставляют готовую инфраструктуру и позволяют избежать таких трудозатрат, что значительно упрощает процесс деплоя.

Следует оговориться, что рынок облачных сервисов достаточно нестабилен и подвержен изменениям. Описываемая в данном разделе ситуация соответствует 2024 году и в последующем, с изменением конъюнктуры, может стать частично или полностью неактуальной, как и представленные здесь инструкции.

Развертывание базы данных
=========================

База данных может быть развернута с помощью того же сервиса, что и основное приложение, но это не является обязательным. Существуют два подхода, которыми можно воспользоваться при облачном развертывании базы данных:

1. Использование управляемого сервиса баз данных (база данных как услуга, Database-as-a-Service, DBaaS), при котором владелец сервиса (провайдер) занимается организацией инфраструктуры, установкой, настройкой и обслуживанием систем управления базами данных, а пользователь получает в распоряжение экземпляр СУБД и полномочия по управлению им.
2. Использование собственноручно настроенной системы управления базами данных, запущенной на облачном ресурсе, при котором все обязанности по установке, настройке и обслуживанию СУБД ложатся на пользователя.
   
У каждого из перечисленных подходов есть преимущества. Использование модели DBaaS позволяет избежать сложностей при установке и настройке СУБД, а соответственно временных и финансовых затрат, а также быть уверенным в надежности сервиса и защищенности данных. Использование же настроенного вручную экземпляра СУБД характеризуется более низкой стоимостью эксплуатации (пользователь платит только за инфраструктуру, но не за обслуживание СУБД) и возможностью более гибкой настройки СУБД.

В данном пособии будет выбран подход использования сервиса с управляемой СУБД ввиду того, что при этом отсутствуют сложности, связанные с настройкой операционной системы, установкой и настройкой СУБД. К счастью, несмотря на то, что DBaaS -- в общем случае более дорогое решение, чем вручную настроенная СУБД, существует достаточное количество проверенных временем провайдеров, предлагающих бесплатные управляемые экземпляры с некоторыми ограничениями.

На момент создания данного пособия бесплатные управляемые экземпляры PostgreSQL предоставляются помимо прочих следующими сервисами:

- Aiven (1 выделенная виртуальная машина, 2 CPU, 1 GB RAM, 5 GB хранилища) [#aivenfree]_,
- Tembo (0.25 vCPU, 1 GB RAM, 10 GB хранилища) [#tembofree]_.
  
Существуют многочисленные альтернативы, но они либо имеют ограничения по количеству активного времени (Vercel Postgres, Neon), либо по времени жизни базы данных (Render), либо представляют собой сервис модели BaaS (Backend-as-a-Service, бэкенд как услуга) и перегружены функционалом, не необходимым для развертывания веб-приложения (Supabase).

Рассмотрим шаги, необходимые для облачного развертывания базы данных с помощью Aiven [#aiven]_ -- платформы данных, позволяющей организовывать сервисы быстрого потокового, хранения и предоставления данных через основные облачные провайдеры.

Необходимо пройти процедуру регистрации, после чего будет предложено заполнить поля профиля. Требуется настроить учетную запись как персональную, в этом случае будет предоставлен доступ к бесплатным сервисам.

Организационная структура Aiven трехуровневая [#aivenorgs]_: Организация -- Проект -- Сервис. Организация чаще всего одна, для персональной учетной записи является просто контейнером для всех личных проектов, а также содержит биллинговую информацию и информацию обо всех пользователях, группах, и определяемых для них ролях и правах. Нужно понимать, что речь идет о пользователях Aiven, имеющих доступ к управлению и настройке сервисов, а не о пользователях приложений, использующих эти сервисы. Организация создается по умолчанию автоматически. Проекты создаются вручную и являются наборами взаимосвязанных сервисов, к которым можно давать доступ пользователям организации. Наконец, управляемые сервисы -- арендуемые облачные ресурсы, которые применяются для развертывания приложения. Кроме PostgreSQL, Aiven предоставляет ограниченные бесплатные управляемые сервисы реляционной СУБД MySQL и нереляционной СУБД Valkey, а также большое количество платных сервисов для работы с данными. У организации может быть только один бесплатный сервис каждого типа.

Поскольку для целей развертывания базы данных создаваемого веб-приложения необходим только одиночный экземпляр PostgreSQL, нет необходимости отвлекаться на настройку организационной структуры Aiven. Требуется создать один проект дав ему любое удобное имя, а после этого -- приступить к созданию сервиса. Типом сервиса требуется выбрать PostgreSQL, после чего выбрать бесплатный план (Free plan). Последний выбор сузит круг остальных настроек сервиса: останется только один облачный провайдер (AWS), малое количество возможных регионов, один тип экземпляра (бесплатный, с 2 CPU, 1 GB RAM, 5 GB хранилища), не будет возможности выбрать дополнительное хранилище. При выборе региона следует отдать предпочтение географическому расположению, максимально близкому к сервису, на котором будет развернуто само приложение, для снижения латентности, то есть задержки при передачи данных по сети. Исходя из предположения, что приложение будет развернуто в Европе, сервис базы данных имеет смысл арендовать там же. Для бесплатного сервиса доступны европейские регионы AWS eu-north-1 (Стокгольм), eu-west-1 (Ирландия), eu-west-2 (Лондон) и eu-west-3 (Париж). Также необходимо выбрать для создаваемого сервиса уникальное имя, либо воспользоваться автоматически сгенерированным. Можно добавить для сервиса теги, удобные для управления большим количеством сервисов, относящихся к разным проектам, но в данном случае в тегах нет никакой необходимости.

Процесс развертывания сервиса занимает несколько минут, в процессе вам будут предложены для ознакомления страницы с описанием способов подключения к созданному экземпляру СУБД (Connection details), возможностью ограничения сетевого доступа к сервису по списку IP-адресов (Allowed inbound IP addresses) и изначального наполнения данными путем миграции существующей базы данных или создания тестовой базы данных (Add data). Эти страницы не содержат информации или функционала, к которым нельзя было бы получить доступ впоследствии.

После успешного создания управляемого экземпляра PostgreSQL с ним можно начинать работу, используя его как интерактивно через какой-либо клиент (например, psql или DBeaver), так и из приложения на Python, подключаясь к нему с помощью psycopg. Необходимые для подключения данные указаны на главной странице созданного сервиса (Overview) в разделе Connection information. Возможно, для удобства имеет смысл сохранить эти данные в переменные окружения, например, с помощью создания файла ``.env``, что описано в соответствующем разделе пособия.

По умолчанию на сервере создается база данных ``defaultdb`` и пользователь с повышенными правами ``avnadmin``. База данных с нужным именем может быть создана как через веб-интерфейс, так и с помощью клиента. Аналогично двумя способами возможно создание нового пользователя. Способ создания нового пользователя через клиент psql с помощью команд SQL рассмотрен ранее в пособии, и является более практичным, поскольку позволяет задавать набор прав для доступа только к конкретной базе данных (пользователи, созданные через веб-интерфейс, имеют доступ ко всем базам данных).

Веб-интерфейс имеет удобную функциональность управления сервисом: позволяет останавливать и запускать сервис, добавлять и удалять пользователей (кроме пользователя ``avnadmin``, страница Users), добавлять и удалять базы данных (кроме базы данных ``defaultdb``, страница Databases), просматривать журнал работы СУБД (страница Logs).

В качестве альтернативы Aiven может быть использован сервис Tembo -- платформа, специализирующаяся на предоставлении управляемых экземпляров PostgreSQL с возможностью подключения большого количества расширений. Рассмотрим особенности развертывания базы данных на этом сервисе.

После регистрации будет предложено выбрать стек (Stack) -- специализацию экземпляра базы данных, чтобы сделать его заточенным под определенные виды рабочих нагрузок. Для целей небольшого веб-приложения подойдет стек Standard, предназначенный для рабочих нагрузок общего типа.

После выбора стека необходимо заполнить форму с деталями создаваемого экземпляра: задать ему имя, выбрать версию PostgreSQL (существенной роли не играет), выбрать облачного провайдера (необходимо выбрать AWS, так как для него доступно большее количество регионов). В качестве региона, как и в случае с Aiven, необходимо выбрать тот, который географически максимально близок к размещению приложения, в данном случае это Europe (Frankfurt). После этого необходимо выбрать один из типов создаваемого экземпляра. Тип влияет на аппаратные характеристики оборудования и определяет стоимость, интерес представляет бесплатный тип (Hobby). После выбора бесплатного типа дальнейшие настройки экземпляра становятся недоступны, и можно завершать заполнение формы.

Интерфейс сервиса Tembo гораздо проще, чем в Aiven, прежде всего за счет отсутствия разных вариантов арендуемых ресурсов (предоставляется только PostgreSQL) и отсутствия возможности управлять структурой организации и пользователями, что не является недостатком при персональном использовании. По сути главная страница представляет собой просто список созданных экземпляров, причем есть возможность создать несколько бесплатных экземпляров для одной учетной записи.

Процесс развертывания занимает несколько минут, и после изменения статуса экземпляра с "Provisioning" на "Good" можно начинать с ним работу. Чтобы подключиться к базе данных клиентом (psql, DBeaver или любым другим), а также из приложения на Python, необходимо перейдя к экземпляру на страницу Dashboard (Панель управления) нажать на кнопку "Show connection strings" ("Показать строки подключения"). В открывающемся окне Connections (Подключения) можно выбрать базу данных и пользователя и получить для них данные для подключения. По умолчанию создается база данных ``postgres`` и пользователи ``postgres`` (роль ``superuser``) и ``readonly`` (роль ``readonly``).  Можно создать базу данных и пользователя с нужными именами, а также назначить для пользователя корректные права (как описано в соответствующем разделе данного пособия) с помощью клиента. Для удобства имеет смысл записать эти данные в переменные окружения, используя файл ``.env``, как описано в соответствующем разделе пособия. 

Стоит отметить, что Tembo предоставляет веб-интерфейс для написания команд на SQL, а также средство просмотра таблиц и редактирования их содержимого (страница SQL Editor). К сожалению, на момент написания пособия онлайн редактирование и просмотр таблиц не очень полезно, так как способно работать только с базой данных ``postgres``.

Журнал работы экземпляра может быть полезен для диагностики проблем и доступен на вкладке Logs страницы Dashboard.

На странице Settings (Настройки) можно управлять настройками PostgreSQL (вкладка Postgres), настройками сети (вкладка Network) а также перезагрузить экземпляр или удалить его (вкладка Instance).

.. [#aivenfree] https://aiven.io/pricing?product=pg
.. [#tembofree] https://tembo.io/pricing/
.. [#aiven] https://aiven.io/postgresql
.. [#aivenorgs] https://aiven.io/docs/platform/concepts/orgs-units-projects

Развертывание приложения
========================

При облачном развертывании приложения также необходимо выбрать один из нескольких подходов.

1. VDS/VPS (Virtual Private Server, Virtual Dedicated Server, виртуальный частный/выделенный сервер). Приложение может быть запущено на арендуемом облачном виртуальном сервере, на котором установлена операционная система и некоторый набор базовых программ. При этом настройкой прикладного программного обеспечения и обеспечением информационной безопасности занимается пользователь. Такой подход характеризуется сложностью настройки и администрирования сервера. Для малого приложения ресурсов выделенного виртуального сервера может быть слишком много, что снижает экономическую эффективность.
2. IaaS (Infrastructure-as-a-Service, инфраструктура как услуга). Такой подход похож на VPS/VDS, но отличается большей гибкостью (так, ресурс не ограничен одним виртуальным сервером и может включать множество серверов, хранилищ, сетей и т.д.), а значит и большей сложностью. Для учебных приложений с учетом трудозатрат на настройку и администрирование не имеет практического смысла.
3. PaaS (Platform-as-a-Service, платформа как услуга). В данной модели поставщик облачных услуг предоставляет готовую инфраструктуру с настроенным программным обеспечением, а пользователь только деплоит код без необходимости администрирования. Такой подход менее гибок, но хорошо подходит для небольших приложений.
4. FaaS (Function-as-a-Service, функция как услуга). Такой подход, также известный как serverless (бессерверный) является экономически эффективным, поскольку не несет затрат при простое приложения, но требует переработки кодовой базы приложения, в виде разделения его на функции, запускаемые по запросу. Подход хорошо подходит для приложений, представляющих собой API или организованных в виде микросервисов.
5. CaaS (Container-as-a-Service, контейнер как услуга). При этой модели пользователь организует приложение в виде контейнера (например, с помощью Docker), а затем разворачивает его на платформе оркестрации. Подход является более гибким, чем PaaS, поскольку имеется возможность масштабирования и настройки среды выполнения для контейнера, но также хорошо подходит для небольших приложений. Следует отметить, что контейнеризованные приложения можно также разворачивать на VDS/VPS и IaaS, но такая модель организации развертывания не избавляет от необходимости администрирования виртуальных серверов и не относится к модели CaaS.
   
В этом разделе будет описано развертывание веб-приложения на сервисе Render, работающем по модели PaaS. Render предлагает бесплатный хостинг веб-приложений на Python и других платформах. Бесплатный экземпляр веб-cервиса обладает следующими характеристиками: 0.1 CPU, 512 MB RAM. При этом у приложения, развернутого по бесплатному тарифу, есть ряд существенных ограничений, делающих его малопригодным для реального использования [#renderfree]_.

- Приложение развертывается в эфемерной файловой системе, отсутствует доступ к персистентному хранилищу. Иными словами приложение не может сохранять какую-либо информацию на жесткий диск (кроме как в базу данных), и все изменения, которые работающее приложение сделает в файловой системе, будут потеряны при следующе развертывании.
- Приложение останавливается после 15 минут неактивности, когда к нему не поступают запросы. Если поступает запрос к остановленному приложению, оно снова запускается, но это может занять порядка одной минуты, в течение которой запрос будет "висеть" и ждать обработки.
- Для бесплатной учетной записи количество времени работы экземпляра составляет 750 часов в месяц, и это количество суммируется для всех приложений. Этого достаточно для непрерывной работы одиночного приложения, но два приложения смогут работать например только половину времени каждое. С учетом автоматической остановки после 15 минут неактивности, которая "экономит" время работы приложения, ограничение не является существенным и позволяет бесплатно размещать и тестировать много проектов.
- Размер исходящего трафика для учетной записи ограничен 100 GB в месяц.
- Суммарное количество времени для сборки приложений составляет 500 минут в месяц (например, сборка вашего приложения занимает 1 минуту, тогда вы сможете задеплоить его 500 раз в месяц).
- Приложение принудительно останавливается без возможности бесплатного возобновления, если оно самостоятельно инициирует большие потоки трафика в интернет, то есть трафика, не являющегося ответом на запросы к приложению. Так, нужно быть предельно "деликатным" при обращении к базе данных, находящейся не на сервисе Render, и не перегонять большое количество данных в нее и из нее.
- Для развернутого сервиса недоступен доступ по SSH.
  
Для начала работы с сервисом Render необходимо создать учетную запись. Удобно регистрироваться с помощью учетной записи GitHub, потому что впоследствии будет возможность подключения репозитория с проектом для легкого деплоя. При регистрации следует указать, что вы предполагаете использовать сервис Render для личных целей и собираетесь разворачивать новый проект.

После завершения процесса регистрации можно сразу развернуть сервис. Впрочем, это можно сделать и впоследствии из дашборда рабочего пространства учетной записи. Проекты в Render, как и в Aiven, служат для группировки связанных сервисов, но их создание является необязательным. Сервисы, созданные без проектов, будут перечислены в списке "Ungrouped services" (Несгруппированные сервисы).

Для создания сервиса необходимо нажать "+ New" и выбрать "Web Service". После этого в пункте Source code (Исходный код) будет предложено подключить git-репозиторий с проектом. Если при регистрации использовалась учетная запись GitHub, То на этом этапе можно просто выбрать репозиторий, который содержит исходный код проекта. Для этого нужно выбрать свою учетную запись, а после этого -- репозиторий или несколько, подключаемых к Render. Имеет смысл выбрать вариант "Only select repositories" (Только выбранные репозитории) и один репозиторий, относящийся к разворачиваемому приложению. Если впоследствии потребуется подключить другие репозитории, это можно сделать в настройках существующего сервиса, на странице Settings (Настройки) пункт Repository (Репозиторий) -- Edit (Изменить), далее GitHub -- Configure account (Настроить аккаунт). При создании нового сервиса можно также выбрать репозиторий из уже подключенных или подключить новый в пункте Souece Code (Исходный код) -- Credentials (Учетные данные) -- Configure GitHub (Настроить GitHub).

Помимо подключения личного репозитория можно развернуть приложение из публичного git-репозитория, либо из Docker-образа.

После подключения репозитория открываются дополнительные настройки создаваемого сервиса:

1. Name (Имя) -- должно быть уникальным для всех сервисов вашей учетной записи.
2. Project (Проект) -- возможность добавления сервиса к существующему проекту или создания нового проекта. Необязательно.
3. Language (Язык) -- среда выполнения для вашего проекта. Необходимо выбрать Python 3.
4. Branch (Ветка) -- ветка репозитория, из котрой будет забираться код проекта. По умолчанию используется master или main.
5. Region (Регион) -- следует выбирать исходя из географического расположения пользователей приложения и реиона развертывания базы данных для уменьшения латентности сети повышения быстродействия приложения. Render поддерживает 5 регионов, если исходить из того, что пользователи будут расположены в европейской части России, а база данных - в Европе, самым подходящим будет размещение приложения в регионе Франкфурт (Центральная Европа).
6. Root Directory (Корневой каталог) -- каталог внутри репозитория, в котором расположены файлы проекта. Если придерживаться рекомендованной в данном пособии структуры каталогов, это корень репозитория.
7. Build Command (Команда сборки) -- команда, которую необходимо выполнить для сборки проекта (см. далее).
8. Start Command (Команда запуска) -- команда, которую необходимо выполнить для запуска проекта (см. далее).
9. Instance Type (Тип экземпляра) -- необходимо выбрать Free (Бесплатный).
10. Environment Variables (Переменные окружения) -- настройка переменных окружения для использования внутри развернутого приложения. Есть возможность также создать файл ``.env`` для загрузки значений переменных окружения в секции Advanced (Дополнительно) -- Secret Files (Файлы с секретами) -- Add Secret File (Добавить файл с секретами). Работа с секретами описана в соответствующем разделе пособия.

Рассмотрим подробнее процесс развертывания веб-приложения [#renderweb]_.

По умолчанию развертывание запускается при изменении кода в указанной ветке подключенного репозитория. Таким изменением может быть push новых коммитов, либо merge какой-либо другой ветки или форка. Автоматическое развертывание можно отключить для сервиса вообще: на странице Settings (Настройки) пункт Auto-Deploy (Автоматическое развертывание). Это может сэкономить время развертывания, которое для бесплатных экземпляров ограниченно, и может исчерпаться, если в развертываемый репозиторий очень часто происходит push. Также есть возможность пропустить развертывание для конкретного коммита, для этого необходимо предварить комментарий к коммиту строкой ``"[skip deploy]"``:

.. code-block:: bash
   
    git commit -m "[skip deploy] Update description"        

Есть возможность запустить деплой вручную, на странице сервиса нажав кнопку "Manual deploy" (Ручное развертывание). При этом можно выбрать коммит для развертывания, пересобрать, либо перезапустить сервис.

При описании запуска приложения на локальной системе использовались виртуальные окружения, которые позволяли изолировать среды выполнения и зависимости разных проектов и избежать конфликтов версий. В случае развертывания по модели PaaS в заботе о виртуальных окружениях нет необходимости, поскольку при развертывании создается изолированная среда, в которой происходит сборка и запуск приложения. Можно упрощенно считать, что виртуальное окружение создается и активируется автоматически.

Для приложения после создания изолированной среды и установки в нее среды выполнения (в данном случае -- Python 3) последовательно выполняются команда сборки, а затем -- запуска.

В случае приложения на Python типичным примером команды сборки является установка зависимостей. Она может производиться, например с помощью pip, как описано в соответствующем разделе пособия.

Необходимо понимать, что в данном пособии при описании запуска приложения на локальном компьютере разработчика использовался встроенный в Werkzeug веб-сервер, который непригоден для реального использования. Поэтому для развертывания с целью промышленного применения имеет смысл воспользоваться более мощным, надежным и функциональным веб-сервером. Главное требование к серверу -- поддержка протокола WSGI для взаимодействия с Python-приложением. Одним из широко распространенных WSGI-серверов является Gunicorn [#gunicorn]_. Он запускается только на Unix-подобных операционных системах и не устанавливается на Windows. Поэтому включать его в список зависимостей в файле ``requirements.txt`` не следует, но при этом он должен быть установлен в деплое на Render (развертывание происходит на GNU/Linux). Выходом может стать создание второго файла с зависимостями, предназначенного для использования на Render (например, ``requirements-render.txt``), в котором будет то же самое содержимое, что и в обычном файле ``requirements.txt``, а также строка ``gunicorn``. Создать такой файл на локальном компьютере можно командами

.. code-block:: bash

    python -m pip freeze > requirements-render.txt
    echo gunicorn >> requirements-render.txt

При выполнении этих команд должно быть кактивировано виртуальное окружение, используемое для запуска проекта на компьютере разработчика. 

В случае существования специализированного файла с зависимостями команда сборки проекта на сервисе Render может иметь вид:

.. code-block:: bash

    python3 -m pip install -r requirements-render.txt

Команда запуска также будет отличаться от использованной для локального запуска (``flask run``). Для запуска веб-сервера Gunicorn используется команда:

.. code-block:: bash

    gunicorn [параметры] myproject:app

Аналогично запуску на встроенном веб-сервере, ``myproject:app`` -- указание на объект приложения ``app`` в файле ``myproject.py``, а наиболее полезные параметры следующие:

-w  Количество рабочих процессов (worker process), которые Gunicorn будет запускать для обработки входящих запросов. Оптимально использовать ``2*n+1`` рабочих процессов, где ``n`` -- количество ядер процессора. Каждый процесс обрабатывает один запрос, соответственно чем больше процессов - тем больше запросов параллельно может обработать приложение. Создавать слишком много рабочих процессов не имеет смысла, поскольку во-первых, параллельное выполнение задач ограничено количеством вычислительных ядер, а во-вторых, каждый процесс потребляет некоторое количество памяти, которая может исчерпаться, что крайне негативно скажется на быстродействии и стабильности системы. С учетом технических характеристик бесплатного экземпляра Render, использовать имеет смысл только один рабочий процесс. На более мощных серверах это количество может быть увеличено.
-b  Сетевой интерфейс и порт, на котором будет запущено приложение (вместо этого может быть использован Unix-сокет). Для развертывания на Render имеет смысл указывать значение в виде ``0.0.0.0:$PORT``, где адрес ``0.0.0.0`` означает, что веб-сервер будет прослушивать все доступные сетевые интерфейсы, а ``$PORT`` означает порт, получаемый из переменной окружения ``PORT``, управляемой Render.

Таким образом, команда запуска на сервисе Render может иметь вид:

.. code-block:: bash

    gunicorn -w 1 -b 0.0.0.0:$PORT myproject:app

После начала развертывания можно наблюдать журнал этого процесса, по которому можно найти и устранить возникающие ошибки.

Успешно развернутое приложение становится доступно в интернете по доменному имени с доменом второго уровня ``onrender.com``, который будет указан в верхней части страницы сервиса. Также в веб-интерфейсе дашборда Render присутствуют полезные инструменты:

- Events (События) -- список событий, относящихся к приложению.
- Logs (Журналы) -- журналы работы веб-приложения, по которым можно отслеживать ошибки, происходящие в процессе его работы.
- Environment (Окружение) -- управление переменными окружения и секретами.
- Settings (Настройки) -- изменение настроек сервиса, которые указывались при его создании (имя, репозиторий, команды сборки и запуска и так далее).


.. [#renderfree] https://render.com/docs/free
.. [#renderweb] https://render.com/docs/web-services
.. [#gunicorn] https://gunicorn.org/